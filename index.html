<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Введение</h1>
    <p>ИСХОДНЫЙ КОД (source code) - набор фраз, слов, специальных символов и т.д. специфичных для языка программирования,описывающих набор инструкций для компьютера. </p>
    <p>Но эти символы, слова и фразы на самом деле непонятны для машины. 
        Есть спец программа: колмпилятор или интерпретатор, которые конвертируют исходный код в набор инструкций, понятных компьютеру.
    </p>

    <h2>Логическое мышление</h2>
    <p>Опытные разработчики рассматривают проблемы с точки зрения алгоритмов - 
        набора шагов, которые нужно выполнить для достижения определенной цели, даже если детали меняются. </p>
    <p>Главное привыкнуть выстраивать решение задач в виде алгоритма.</p>

    <h2>Javascript</h2>
    <p>Javascript - результат спецификации EcmaScript, высокоуровневый язык программирования. 
        Изначально предназначался для взаимодействия с эл-тами веб-страниц и добавления интерактивности. </p>
        <p>В фронт-энд разработке JS используется с HTML и CSS для следующих задач:</p>
        <ul>
            <li>Несложные вычисления</li>
            <li>проверка и манипуляция введенными пользователем данными</li>
            <li>хранение информации в браузере пользователя</li>
            <li>динамическое изменение HTML-документа</li>
            <li>реакция на действия пользователя</li>
            <li>создание интерактивных элементов: галлерей, графиков и т. д.</li>
            <li>взаимодействие с сервером и базой данных</li>
        </ul>

    <b>ВАЖНО!!!</b>
    <p>Если JavaScript-код пишется для исполнения в браузере (Front-end), у разработчика нет инструментов и доступа 
        к файловой или операционной системе по соображениям безопасности.</p>
    <p>На сегодняшний день с помощью JS можно создавать:</p>
    <ul>
        <li>веб-приложения используя фреймворки React, Vue, Angular и другие</li>
        <li>бекенд-приложения на Node.js</li>
        <li>мобильные приложения используя React Native или Ionic
        </li>
        <li>десктоп-приложения с помощью Electron</li>
        <li>микроконтроллеры с Johnny-Five и Espruino</li>
    </ul>

    <h1>СИНТАКСИС ЯЗЫКА</h1>
    <h2>Инструкция</h2>
    <p>Инструкция (statement) — это связанный набор слов и символов из синтаксиса языка,
         которые объединяются, чтобы выразить одну идею, одну инструкцию для машины.</p>
         <b>a = b * 2;</b>
    <p>Это пример инструкции. В JavaScript можно различить инструкцию по точке с запятой в конце.</p>
    <ul>
        <li>a и b — переменные (как в алгебраическом уравнении), это хранилища данных которые использует программа. 
            Переменная состоит из идентификатора (имени) и связанного с ним значения.</li>
        <li>2 — просто число. Это называется значением литерала (literal value), так как оно не хранится в переменной.</li>
        <li>= и * — операторы, производят действия над значениями и переменными.</li>
    </ul>
    <p>Представим что переменная b уже хранит число 10. Тогда эта инструкция говорит машине:</p>
    <ul>
        <li>Пойди найди переменную с идентификатором b и спроси какое у нее сейчас значение</li>
        <li>Подставь значение переменной b в утверждение на место b</li>
        <li>Умнож 10 на 2</li>
        <li>После чего, запиши результат вычисления выражения правой части в переменную a.</li>
    </ul>

    <h2>ВЫРАЖЕНИЕ</h2>
    <p>Инструкции состоят из частей, как в любом языке предложения состоят из фраз, и эти фразы называются выражениями.</p>
    <p>Выражение (expression) — ссылка на переменную или значение,
         или на набор переменных и значений в сочетании с операторами.</p>
        <b>[ [a] = [ [b] * [2] ] ] </b>
    <p>Инструкция из примера выше содержит 5 выражений,
         для визуализации выделены квадратными скобками (это не синтаксис языка):    </p>
         <ul>
             <li>[2] — выражение значения литерала.</li>
             <li>[b]и[a] — выражения переменной</li>
             <li>[b * 2] — арифметическое выражение умножения.</li>
             <li>[a = b * 2] — выражение присваивания. В нашем случае указывает на необходимость вычисления
                  правой части выражения и присваивания результата переменной a в левой части выражения.</li>
         </ul>
         <p>Так же есть выражения вызова, выражения сравнения и т. д.</p>

         <h2>ИНТЕРФЕЙС</h2>
         <p>Элементы управления, с которыми можно взаимодействовать называются ИНТЕРФЕЙС.</p>
         <p><b>Интерфейс</b> — это набор свойств и методов сущности, доступных для использования.</p>

         <h3>СВОЙСТВО</h3>
         <p>У данных есть свойства, к примеру у строки есть свойство ее длины.</p>
         <p>Для наглядности, обратимся к свойству строки length, которое содержит кол-во символов строки.</p>
         <b>'JavaScript is awesome'.length;</b>

         <h3>МЕТОД</h3>
         <p>МЕТОД - это вызов действия. то есть какая-то активная операция. 
             Так же и у данных есть свои методы, например можно добавить или удалить элементы из коллекции, 
             перевести строку в разный регистр и т. д. 
             Синтаксис вызова метода очень похож на обращение к свойству, но в конце добавляется пара скобок.</p>
             <b>сущность.имя_метода()</b>
             <p>Для примера обратимся к методу строки toUpperCase(), который сделает все буквы заглавными.</p>
             <b>'JavaScript is awesome'.toUpperCase();</b>


        <h1>ПЕРЕМЕННЫЕ</h1>
        <p>Переменные используются для хранения данных и состоят из идентификатора (имени) и области в памяти,
             где хранится их значение.
             Переменную можно представить как коробку с названием, в которой что-то лежит (значение).</p>

        <h2>Имена переменных</h2>
        <a href="https://bookflow.ru/kak-nazyvat-peremennye/">Как называть переменные</a>
        <a href="https://www.freecodecamp.org/news/javascript-naming-conventions-dos-and-don-ts-99c0e2fdd78a/">
        JavaScript naming conventions</a>

        <h2>Ключевые слова</h2>
        <p>Есть список зарезервированных ключевых слов, которые имеют специальное значение
             и используются для определенных конструкций.
             Нельзя использовать ключевые слова как идентификаторы.</p>
             <a href="https://www.w3schools.com/js/js_reserved.asp">
            Таблица зарезервырованных слов</a>

        <h2>Объявление переменных</h2>
        <p>В современном JavaScript есть 2 ключевых слова для объявления переменных.</p>
        <ul>
            <li>let — объявляет переменную, которой можно присвоить новое значение после объявления, то есть переопределить.
                <br> let age;
            </li>
            <li>const — так же объявляет переменную, но с одним отличием: 
                объявляемая переменная должна быть немедленно инициализирована значением,
                 и этой переменной не может быть присвоено другое значение после инициализации.
                 <br>const yearOfBirth = 2006;
            </li>
        </ul>

        <b>	
            Создание переменной без ключевого слова let или const приведет к ошибке.</b>
    <p>Eсли перемнной объявленной как let, изначально не присвоено значение,
        она инициализируется специальным значением undefined (не определено). <br>
       console.log(age); // undefined</p>
       <p>Если переменная объявлена как let, ее значение можно перезаписать. <br>
        */
       age = 14; <br>
       console.log(age); // 14</p>

       <p>Если попробовать перезаписать const переменную, то консоль выдаст ошибку. </p>

       <h2>КОНСТАНТЫ</h2>
       <p>Имена КОНСТАНТ - переменных, значение которых не изменяется никогда на протяжении работы всего скрипта,
            обычно записываются в формате UPPER_SNAKE_CASE.</p>
            <p>// Константа хранящая значение цвета <br>
                const COLOR_TEAL = '#009688'; <br>
                // Константа хранящая сообщение о авторизации <br>
                const MESSAGE_LOGIN_SUCCESS = 'Добро пожаловать!';</p>

        <h2>Обращение к переменной</h2>
        <p>Важно различать неопределенные и необъявленные переменные.</p>
        <ul>
            <li> <b> Неопределенная (undefined) </b> — это переменная, которая была объявлена, 
                но не инициализирована значением, 
                по умолчанию ей присваевается значение undefined как начальное.</li>
                <li>
                    <b>Необъявленная (undeclared или not defined)</b> — 
                    это переменная, которая не была объявлена в доступной области видимости.
                </li>
        </ul>
        <p>
            let name; <br>

           
            * Переменная name объявлена, но не инициализирована, поэтому
            * ее значение undefined (не определено), тогда как переменная age
            * не была объявлена, поэтому доступ к ней вызывает ошибку ReferenceError
            */
            console.log(name); // undefined
            console.log(age); // ReferenceError: age is not defined
        </p>

    <h1>Типы примитивов</h1>
    <p>JavaScript это динамический, слабо типизированный язык. <br>
    Поэтому переменные не различаются по типу данных. Но по типу данных различаются значения переменных! </p>
    <h2>Number</h2>
    <p>Целые числа и числа с плавающей запятой. 
        После объявления переменной, можно инициализировать ее числовым значением. <br>
        const age = 20;</p>

    <h2>String</h2>
    <p>Строки это просто текст, последовательность из нуля или более символов. 
        Строка начинается и заканчивается одиночной ', или двойными кавычками ". 
        Открывающая и закрывающая кавычки должны быть одинаковые. <br>
        const name = 'Mango';</p>

    <h2>Boolean</h2>
    <p>Логический тип данных, флаги состояния. Имеет только два значения: true и false, в нижнем регистре. 
        Например на вопрос включен ли свет в комнате можно ответить да (true) или нет (false).</p>
    
    <ul>
        <li>
            true — да, верно, истина, 1
        </li>
        <li>false — нет, неверно, ложь, 0</li>
    </ul>

    <p>Обратите внимание на имена переменных содержащих буль. Они задают вопрос, и ответ на его — да или нет. <br>
        const isAuthenticated = true; <br>
        const canMerge = false; <br>
        const hasChildren = true; <br>
        const isModalOpen = false;</p>

    <h2>NULL</h2>
    <p>Особое значение, которое по сути значит ничто. 
        Используется в тех ситуациях, когда необходимо явно указать отсутсвие значения. 
        К примеру если в базе данных не нашли пользователя, то можно сказать что значение null.</p>

    <h2>Undefined</h2>
    <p>Еще одно специальное значение. По умолчанию, когда переменная объявляется, 
        но не инициализируется, ее значение не определено, ей присваивается undefined.
    <br> let name; <br>
    console.log(name); // undefined
</p>
 <h2>Оператор typeof</h2>
 <p>Для получения типа значения переменной, используется оператор typeof, 
     который возвращает на место своего вызова тип значения переменной указанного после него. 
     Возвращаемое значение это просто строка в которой указан тип.</p>

     <p>
        // undefined <br>
        let a; <br>
        console.log(typeof a); // "undefined" <br>
         <br>
        // null <br>
        const b = null; <br>
        console.log(typeof null); // "object" <br>
         <br>
        // Number <br>
        const c = 5; <br>
        console.log(typeof c); // "number" <br>
         <br>
        // String <br>
        const d = 'JavaScript is awesome!'; <br>
        console.log(typeof d); // "string" <br>
         <br>
        // Boolean <br>
        const e = false; <br>
        console.log(typeof e); // "boolean" <br>
        
     </p>

     <h1>Взаимодействие с пользователем</h1>
     <h2>Вывод данных</h2>
     <p>
        const message = 'JavaScript is awesome!'; <br>
        console.log(message); // JavaScript is awesome!
     </p>
     <p>
        const name = 'Mango'; <br>
        console.log('My name is: ', name); // My name is: Mango <br>
        /*
         * Можно сначала указать какую-то произвольную строку,
         * к примеру описывающую переменную или дополняющую ее, после чего
         * поставить запятую и указать имя переменной
         */
        
     </p>

     <a href="https://medium.com/free-code-camp/how-to-use-the-javascript-console-going-beyond-console-log-5128af9d573b">
        How to use the JavaScript console: going beyond console.log()</a>

    <h2>Получение данных</h2>
    <p>Для получения данных от пользователя будем использовать prompt() и confirm(), 
        это тоже методы из интерфейса window. Их особенность в том, что результатом своего выполнения 
        они возвращают то, что было введено пользователем. 
        Результат их работы можно записать в переменную для дальнейшего использования.</p>

    <p>confirm() — выводит модальное окно с сообщением, и 2 кнопки, Ok и Cancel. 
        При нажатии на Ok, на место вызова функции возвращается true, при нажатии на Cancel возвращается false.</p>
        <p>
            const isComing = confirm('Please confirm hotel reservation'); <br>
            console.log(isComing);
        </p>

        <p>
            prompt() — выводит модальное окно с полем ввода и кнопками Ok и Cancel. 
            При Ok возвращает то, что было введено в поле ввода, при Cancel возвращает null. <br>

            const hotelName = prompt('Please enter desired hotel name:'); <br>
            console.log(hotelName);
        </p>
        <p>
            /*
            * <b> Важная особенность prompt </b> в том, что не зависимо что ввел пользователь,
            * всегда вернется строка. Тоесть если пользователь ввел 5, то вернется
            * не число 5, а строка "5". Об этом необходимо всегда помнить. <br>

            const value = prompt('Please enter a number!'); <br>
            console.log(typeof value); // 'string' <br>
            console.log(value); // '5'
        </p>

        <h1>Основные операторы</h1>
        <h2>Математические операторы</h2>
        <p>Важно запомнить правильное именование составляющих выражения. + - * / % называются операторами, 
            а то на чем они применяются операндами.</p>
        <ul>
            <li>// Операции с числами <br>
                const x = 10; <br>
                const y = 5;</li>
            <li>// Сложение <br>
                console.log(x + y); // 15
            </li>
            <li>// Вычитание <br>
                console.log(x - y); // 5
            </li>
            <li>// Умножение <br>
                console.log(x * y); // 50
            </li>
            <li>// Деление <br>
                console.log(x / y); // 2
            </li>
            <li>// Остаток от деления <br>
                console.log(x % y); // 0
            </li>
            <li>// Сложение с заменой (есть и для других операторов) <br>
                let value = 5;
            </li>
            <li>// Аналогично записи value = value + 10; <br>
                value += 10; <br>
                console.log(value); // 15
            </li>
        </ul>
    <h2>Операторы сравнения</h2>
    <p>Используются для сравнения значений. Результатом своего выполнения возвращают були, true или false.</p>
    <ul>
        <li><code>a > b и a < b</code> - больше/меньше</li>
        <li><code>a >= b и a <= b</code> - больше/меньше или равно</li>
        <li>a == b - равенство</li>
        <li>a != b - неравенство</li>
        <li>a === b - строгое равенство</li>
        <li>a !== b - строгое неравенство</li>
    </ul>
<p><b>ЗАПОМНИТЬ</b> что операторы сравнения на выходе выдают Boolean</p>

<h2>== и ===</h2>
<p>Всегда используйте строгое равенство === и строгое неравенство !==. 
    При таком условии всё может быть равно только себе. <br>
При нестрогом неравенстве происходит преобразование типов значения, 
т.е. значение number может приравняться к значению string и др.
</p>

<h1>Числа</h1>
<p>Все числа в JS имеют тип Number.</p>
<h2>Приведение к числу</h2>
<p>Большинство арифметических операций и математических функций преобразуют значение в число автоматически. <br>
     Для того чтобы сделать это явно, используйте функцию Number(val), 
     передавая ей в val то, что надо привести к числу.</p>
<p>Если значние не возможно привести к числу, результатом будет специальное значение NaN (Not a Number).</p>

<p>const valueA = '5';  <br>
    console.log(Number(valueA)); // 5  <br>
    console.log(typeof Number(valueA)); // 'number'</p>

<p>const valueB = 'random string';   <br>
    console.log(Number(valueB)); // NaN   <br>
    console.log(typeof Number(valueB)); // 'number'</p>

<h2>Number.parseInt() и Number.parseFloat()</h2>
<p>Методы преобразуют строку символ за символом, пока это возможно. 
    При возникновении ошибки возвращается число, которое получилось.</p>

    <p>// Парсит из строки целое число   <br>
        console.log(Number.parseInt('5px')); // 5   <br>
        console.log(Number.parseInt('12qwe74')); // 12   <br>
        console.log(Number.parseInt('12.46qwe79')); // 12   <br>
        console.log(Number.parseInt('qweqwe')); // NaN
        
    </p>
    <p>// Парсит из строки дробное число   <br>
        console.log(Number.parseFloat('5px')); // 5   <br>
        console.log(Number.parseFloat('12qwe74')); // 12   <br>
        console.log(Number.parseFloat('12.46qwe79')); // 12.46   <br>
        console.log(Number.parseFloat('qweqwe')); // NaN
    </p>

    <p>Вероятно можно применять как фильтр для какого-то поля ввода данных, чтобы забирать только числовые данные</p>

    <h2>Проверка на число</h2>
    <p>Для проверки на число можно использовать метод Number.isNaN(val). 
        Он проверяет, является ли указанное значение NaN или нет. 
        Этот метод отвечает на вопрос "Это Not A Number?", и возвращает:</p>

        <ul>
            <li>true — если значение val это NaN</li>
            <li>false — если значение val это не NaN</li>
        </ul>
    <p>const validNumber = Number('51'); // 51    <br>
        console.log(Number.isNaN(validNumber)); // false    <br>
        
        const invalidNumber = Number('qweqwe'); // NaN    <br>
        console.log(Number.isNaN(invalidNumber)); // true
    </p>
    <h2>Сложение чисел с плавающей точкой</h2>
    <p>При сложении не целых чисел в JavaScript, и других языках программирования, есть особенность. 
        Если кратко, то 0.1 + 0.2 не равно 0.3, результат сложения больше чем 0.3. 
        Все от того что машина считает в двоичной системе.</p>

    <p>Число 0.1 в двоичной системе счисления это бесконечная дробь, 
        так как единица на десять в двоичной системе не делится. 
        Также бесконечной дробью является 0.2. Двоичное значение бесконечных дробей 
        хранится только до определенного знака, поэтому возникает неточность. 
        При сложении 0.1 и 0.2, две неточности складываются, 
        получается незначительная, но всё же ошибка в вычислениях.</p>

    <p>console.log(0.1 + 0.2 === 0.3); // false   <br>

        console.log(0.1 + 0.2); // 0.30000000000000004</p>
    
    <p>Конечно, это не означает, что точные вычисления для таких чисел невозможны. 
        Есть несколько методов решения этой проблемы:</p>

    <ul>
        <li>Сделать их целыми, умножив на 10, сложить, а потом результат разделить на 10</li>
        <li>Сложить, а затем округлить до разумного знака после запятой.</li>
        <li>Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений</li>
    </ul>
<p>// Сделать их целыми, умножив на 10, сложить, а результат разделить на 10 <br>
    console.log((0.1 * 10 + 0.2 * 10) / 10);</p>

<h2>Объект Math</h2>
<p>Один из встроенных объектов в язык. Предоставляет набор методов для работы с числами. 
    Знание всех методов наизусть не требуется, только некоторых, наиболее полезных.</p>
    
<p>//  Math.floor(num) - возвращает наибольшее целое число, меньшее, либо равное указанному      <br>
    console.log(Math.floor(1.7)); // 1      <br>
    
    // Math.ceil(num) - возвращает наименьшее целое число,
    // большее, либо равное указанному числу.      <br>
    console.log(Math.ceil(1.2)); // 2      <br>
          <br>
    // Math.round(num) - возвращает значение числа, округлённое до ближайшего целого      <br>
    console.log(Math.round(1.2)); // 1      <br>
    console.log(Math.round(1.5)); // 2      <br>
          <br>
    // Math.max(num1, num2, ...) - возвращает наибольшее число из набора      <br>
    console.log(Math.max(20, 10, 50, 40)); // 50      <br>
          <br>
    // Math.min(num1, num2, ...) - возвращает наименьшее число из набора      <br>
    console.log(Math.min(20, 10, 50, 40)); // 10      <br>
          <br>
    // Math.pow(base, exponent) - возведение в степень      <br>
    console.log(Math.pow(2, 4)); // 16      <br>
          <br>
    // Math.random() - возвращает псевдослучайное число в диапазоне [0, 1)      <br>
    console.log(Math.random()); // случайное число между 0 и 1      <br>
    console.log(Math.random() * (10 - 1) + 1); // случайное число от 1 до 10</p>

    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">
    Документация Math на MDN
    </a>




    <h1>Строки</h1>
    <p>Строка — это индексированный набор из нуля или более символов, заключенных в одинарные либо двойные кавычки. <br>
        const name = 'Mango';
    </p>
    <p>Важно помнить что индексация элементов строки начинается с нуля. 
        К примеру в строке 'JavaScript' буква 'J' стоит на позиции с индексом 0, а 't' идет под индексом 9.</p>
    <img src="./img/string-idx.jpg" alt="">
    <p>Содержимое строки нельзя изменить. Нельзя взять символ посередине и заменить его. 
        Как только строка создана — она такая навсегда. 
        Можно лишь создать целиком новую строку и присвоить в переменную вместо старой.</p>

    <h2>Конкатенация строк    </h2>
    <p>Если применить оператор + к строке и любому другому типу данных, результатом операции «сложения» будет строка. 
        Эта операция называется конкатенация, или сложение строк.</p>
    <p>Во время конкатенации, любой тип данных приводится к строке и сшивается со строкой, 
        но есть особенность — последовательность записи операндов.</p>
    <p>Последовательность операций имеет значение, 
        преобразование типов происходит только в момент операции сложения со строкой, 
        до этого момента действуют привычные правила математики.</p>
    <p>const message = 'Mango ' + 'is' + ' happy';   <br>
        console.log(message); // Mango is happy   <br>
        <br>
        // Теперь посмотрим на порядок операндов   <br>
        let result;   <br>
        <br>
        result = 5 + '5';   <br>
        console.log(result); // '55'   <br>
        console.log(typeof result); // string   <br>
        <br>
        result = 5 + '5' + 5;   <br>
        console.log(result); // '555'   <br>
        console.log(typeof result); // string   <br>
        <br>
        /*   <br>
         * Обратите внимание, произошла математическая операция   <br>
         * сложения для первых двух пятерок, после чего 10 было   <br>
         * преобразовано в строку '10' и сшито с '5'   <br>
         */   <br>
        result = 5 + 5 + '5';   <br>
        console.log(result); // '105'   <br>
        console.log(typeof result); // string</p>


        <h2>Свойства и методы строк</h2>
        <p>У каждой строки есть встроенные свойства и методы, рассмотрим некоторые из них.</p>
        <ul>
            <li>length - свойство, хранит длину строки</li>
            <li>toLowerCase() и toUpperCase() - вернут новую строку в соответствующем регистре, 
                не изменяют оригинальную строку</li>
            <li>indexOf() - вернет позицию (индекс) на которой находится первое совпадение подстроки 
                или -1, если ничего не найдено</li>
            <li>includes() - один из наиболее часто используемых методов, в большинстве случаев заменяет indexOf, 
                проверяет входит ли подстрока в строку, возвращает true или false</li>
        </ul>
    <p>
        const message = 'Welcome to Bahamas!'; <br>
 <br>
        console.log(message.length); // 19 <br>
        console.log('There is nothing impossible to him who will try'.length); // 47 <br>
 <br>
        console.log(message.toLowerCase()); // welcome to bahamas! <br>
        console.log(message.toUpperCase()); // WELCOME TO BAHAMAS! <br>
 <br>
        // При этом исходная строка не изменяется <br>
        console.log(message); // Welcome to Bahamas! <br>
 <br>
        console.log(message.indexOf('to')); // 8 <br>
        console.log(message.indexOf('hello')); // -1 <br>
 <br>
        // Все методы строк чувствительны к регистру <br>
        console.log(message.includes('welcome')); // false <br>
        console.log(message.includes('Welcome')); // true <br>

    </p>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Methods_2">
        Полный список методов на MDN</a>
    

        <h2>Шаблонные строки и интерполяция</h2>
    <p>Шаблонные строки это альтернатива конкатенации с более удобным синтаксисом. 
        Они заключены в обратные кавычки вместо двойных или одинарных и могут содержать местозаполнители, 
        которые обозначаются знаком доллара и фигурными скобками.</p>
<img src="./img/interpolation.jpg" alt="">

<h1>Логические операторы</h1>
<h2>Двоичная логика</h2>
<p>Любая программа может быть создана на основе нескольких принципов: последовательности выполнения и ветвлений.</p>
<p><b>Последовательность выполнения</b> - следование записи кода сверху вниз. 
    Но не всегда программа должна выполняться строго последовательно. 
    Для изменения последовательности используются циклы и ветвления.</p>

<p><b>Ветвления</b> - возможность выполнить ту или иную последовательность кода в зависимости от условия. 
    Условие может быть любым, 
    но результат его проверки всегда будет одним из двух значений true или false.</p>

<p>Компьютер использует бинарный (от латинского bis - дважды) код. 
    Т.е. всего два значения используются для создания любых программ: 0 и 1. 
    Это значит, что условия также задаются в виде 0 (нет, false) и 1 (да, true).</p>

<p>В математике существует раздел булевой логики, в котором условия бинарны, 
    т.е. могут быть представлены в виде 0 и 1, а также в виде слов true и false. 
    Именно эта логика используется для реализации ветвления.</p>

    <h3>Приведение типов</h3>
<p>Для того чтобы работала булевая логика необходимо на входе иметь два значения. 
    Поэтому в JavaScript, в логических операциях, осуществляется приведение типов операндов к true или false. 
    Приведение происходит если в коде обнаружен логический оператор.</p>

<p>Truthy и Falsy — термины, которые используются для тех значений, 
    которые в логической операции приводятся к true или false, хотя изначально не были булями.</p>

<b>ВАЖНО ЗАПОМНИТЬ</b>
<p>Запомните 6 ложных (falsy) значений, приводящихся к false в логическом преобразовании: 
    0, NaN, null, undefined, пустая строка: "" или '', false. 
    Абсолютно все остальное приводится к true.</p>

<h2>2. Логические операторы</h2>
<p>Есть три логических оператора, которые используются для проверки выполнения множественных выражений.</p>
<img src="./img/boolean-operators.jpg" alt="">

<h3>2.1. Логическое «И»</h3>
    <p>Оператор && приводит все операнды к булю и возвращает одно из значений (операндов). 
        Левый операнд если его можно привести к false, и правый в остальных случаях.</p>
    <p>const num = 20; <br>
            const result = num > 10 && num < 30; <br>
            console.log(result); // true
    </p>
    <p>В коде выше мы проверяем условие: переменная num больше 10 и меньше 30. 
        Так как оба условия вернут true, то и результатом всего выражения будет true.</p>
    <p>Для того чтобы оператор && вернул true, требуется чтобы все операнды были истинными (truthy). 
        Если хотябы один из операндов будет приведен к false, то результатом выражения будет этот операнд.</p>
    <p>const num = 40; <br>
        const result = num > 10 && num < 30; <br>
        console.log(result); // false</p>
    
    <h2>2.2. Логическое «ИЛИ»</h2>
    <p>Оператор || возвращает одно из значений (операндов). 
        Левый операнд если его можно привести к true, и правый в остальных случаях.</p>
        <p>const num = 5; <br>
        const result = num < 10 || num > 30; <br>
        console.log(result); // true</p>
        <p>Это тоже будет true так как хотябы один из операндов был приведен к true.</p>
        <p>const num = 40; <br>
            const result = num < 10 || num > 30; <br>
            console.log(result); // true</p>

        <p>А тут ни одно из условий не выполняется, поэтому получаем false.</p>
        <p>const num = 20; <br>
            const result = num < 10 || num > 30; <br>
            console.log(result); // false</p>
        
        <h2>2.3. Логическое «НЕ»</h2>
        <p>Оператор ! приводит операнд к булю, если необходимо, а затем заменяет его на противоположный.</p>
        <p>console.log(!true); // false <br>
            console.log(!false); // true <br>
            console.log(!1); // false <br>
            console.log(!0); // true</p>

        <h2>2.4. Порядок вычисления </h2>
        <p>При выполнении логических операций, правый операнд может не вычисляться.</p>
        <img src="./img/order.jpg" alt="">
        <p>"Купить билет И отдохнуть" - если левый операнд "Купить билет" окажется false, 
            то вычислять второй нет смысла.</p>
        <p>"Отдохнуть ИЛИ сохранить деньги" - если левый операнд "Отдохнуть" окажется true, 
            то вычислять второй нет смысла.</p>
        
            <h1>Дополнительные материалы</h1>
            <a href="https://blog.usejournal.com/mastering-javascripts-and-logical-operators-fd619b905c8f">
                Mastering JavaScript’s && and || logical operators</a>
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators">
                MDN: Логические операторы</a>
            <a href="https://www.youtube.com/watch?v=UvI-AMAtrvE&feature=youtu.be">
                Logic Gates Explained (видео)</a>


        <h1>ВЕТВЛЕНИЯ</h1>
        <h2>1. Операторы ветвеления</h2>
        <p>Логические операторы не могут самостоятельно управлять потоком выполнения программы, 
            для этого используются ветвления. Все они устроены по одному принципу - 
            входные данные приводятся к булю (true или false) и, 
            в зависимости от результата этого значения, поток программы направляется в ту или иную ветку.</p>

        <h2>2. Инструкция if</h2>
        <img src="./img/if.jpg" alt="">
        <p>Входные данные, которые приводятся к булевому типу называются условием. 
            Условие помещают за оператором if в круглых скобках. 
            Если условие приводится к true, то выполняется код в фигурных скобках (ветка).</p>

        <p>let cost = 0;<br>
            const subscription = 'pro';<br>
            <br>
            if (subscription === 'pro') {cost = 100;}<br>
            <br>
            console.log(cost); // 100
        </p>
        <p>Если условие приводится к false, код в фигурных скобках будет пропущен.</p>
        <p>let cost = 0;<br>
            const subscription = 'free';<br>
            <br>
            if (subscription === 'pro') {cost = 100;}<br>
            <br>
            console.log(cost); // 0
        </p>

        <h2>2.1. Инструкция if...else</h2>
        <img src="./img/if-else.jpg" alt="">
        <p>Расширяет синтаксис оператора if тем, что в случае если условие приводится к false, 
            выполнится код в фигурных скобках после оператора else.</p>
            <p>let cost;                                          <br>
                const subscription = 'free';                                          <br>
                                                          <br>
                if (subscription === 'pro') {                                          <br>
                  cost = 100;                                          <br>
                } else {                                          <br>
                  cost = 0;                                          <br>
                }                                          <br>
                                                          <br>
                console.log(cost); // 0
            </p>
            <p>При true, оператор else и связанный с ним программный блок, игнорируются.</p>
            <p>let cost;                                            <br>
                const subscription = 'pro';                                            <br>
                                                            <br>
                if (subscription === 'pro') {                                            <br>
                  cost = 100;                                            <br>
                } else {                                            <br>
                  cost = 0;                                            <br>
                }                                            <br>
                                                            <br>
                console.log(cost); // 100
            </p>

            <h2>2.2. Инструкция else...if</h2>
            <img src="./img/if-else-if.jpg" alt="">
            <p>Расширяет синтаксис оператора if...else тем, что после else снова добавляется оператор if. 
                На первый взгляд код из множества подобных вложений кажется сложным. 
                На самом деле все ответвления это результат false на все предыдущие вопросы.</p>

            <p>При первом же true проверки прекратятся и выполнится только один сценарий, соотвествующий этому true. 
                Поэтому подобную запись следует читать как: ищу первое совпадение условия, игнорирую все остальное.</p>

            <p>let cost;                                                 <br>
                const subscription = 'premium';                                                 <br>
                                                                 <br>
                if (subscription === 'free') {                                                 <br>
                  cost = 0;                                                 <br>
                } else if (subscription === 'pro') {                                                 <br>
                  cost = 100;                                                 <br>
                } else if (subscription === 'premium') {                                                 <br>
                  cost = 500;                                                 <br>
                } else {                                                 <br>
                  console.log('Invalid subscription type');                                                 <br>
                }                                                 <br>
                                                                 <br>
                console.log(cost); // 500
            </p>
             <h2>3. Тернарный оператор</h2>
             <p>Есть конструкция, похожая на if...else, с упрощенным синтаксисом, 
                 называемая тернарный оператор (ternary - тройной). <br>
                 {условие} ? {выражение если условие правдиво} : {выражение если условие не правдиво}
            </p>
            <p>Такая конструкция работает следующим образом:</p>
            <ul>
                <li>Вычисляется условие</li>
                <li>Если условие истинно (true), вычисляется выражение после ?, в противном случае значение после :</li>
                <li>Результат вычисленного выражения возвращается</li>
            </ul>
            <p>let type;                                                 <br>
                const age = 20;                                                 <br>
                                                                 <br>
                if (age >= 18) {                                                 <br>
                  type = 'adult';                                                 <br>
                } else {                                                 <br>
                  type = 'child';                                                 <br>
                }                                                 <br>
                </p>
                <p>Перепишем пример используя тернарный оператор.</p>
                <p>const age = 20; <br>
                    const type = age >= 18 ? 'adult' : 'child';</p>
            <p>Запишем операцию поиска большего числа.</p>
            <p>const num1 = 5;                                                       <br>
                const num2 = 10;                                                       <br>
                let biggerNumber;                                                       <br>
                                                                       <br>
                if (num1 > num2) {                                                       <br>
                  biggerNumber = num1;                                                       <br>
                } else {                                                       <br>
                  biggerNumber = num2;                                                       <br>
                }                                                       <br>
                                                                       <br>
                console.log(biggerNumber); // 10
                </p>

                <p>Код работает верно, получаем большее число из двух, но это решение кажется слишком громоздким, 
                    учитывая, насколько проста проблема. Что делать? Используем тернарный оператор.</p>

                <p>const num1 = 5;                                 <br>
                    const num2 = 10;                                 <br>
                    const biggerNumber = num1 > num2 ? num1 : num2;                                 <br>
                    
                    console.log(biggerNumber); // 10
                    </p>

                <p>Тернарный оператор используется только при простых операциях. </p>

    <h2>4. Инструкция switch</h2>
    <p>В некоторых случаях сложности чтения логических конструкций можно избежать, 
        используя оператор ветвления switch. Синтаксис этого оператора разбивает условие на общую часть switch
         и множество отдельных случаев case. Т.е. применимость этого оператора ограничена только задачами
          с одним общим вопросом и множеством вариантов ответов.</p>
    <img src="./img/switch.jpg" alt="">
    <p>Значение выражения - строка или число, которое сравнивается со всеми значениями case. 
        Если совпадения не произошло, управление передается default. 
        Оператор break в завершении каждого блока case ставят чтобы прервать дальнейшие проверки 
        и сразу перейти к коду за инструкцией switch.</p>
    <img src="./img/switch1.jpg" alt="">
    <p>Если оператор break будет отсутствовать, то после того как выполнится какое-то условие case, 
        все последующие за ним блоки кода будут выполняться один за другим, 
        что может привести к нежелательным последствиям при неверном применении.</p>
    

    <h1>1. Область видимости</h1>
    <p>Область видимости переменных (variable scope) - доступность переменных в определенном месте кода. 
        Есть несколько областей видимости: глобальная, блочная, eval и функции.</p>
    <p>Глобальная область видимости используется по умолчанию. 
        Все и вся имеют доступ к переменным объявленным в ней. 
        Переменные объявленные в глобальной области видимости уязвимы, 
        так как их может изменить любой участок кода.</p>

    <p>Рассмотрим на примере. Переменная value объявлена в глобальной области видимости, 
        то есть вне какого-то блока, и доступна в любом месте после объявления.</p>
    <p>const value = 5;                                                <br>
                                                <br>
        if (true) {                                                <br>
          console.log('Block scope: ', value); // 5                                                <br>
        }                                                <br>
                                                        <br>
        console.log('Global scope: ', value); // 5</p>
    <p>Любая конструкция использующая фигурные скобки {} (условия, циклы, функции и т. п.) 
        создает новую локальную область видимости, и переменные, объявленные в этой области видимости, 
        используя let или const, не доступны вне этого блока.</p>
    <p>if (true) {                                                   <br>
        const value = 5;                                                   <br>
        console.log('Block scope: ', value); // 5                                                   <br>
      }                                                   <br>
                                                         <br>
      console.log('Global scope: ', value); // ReferenceError: value is not defined</p>
    <p>Глубина вложенности областей видимости не ограничена, и все они буду работать по одному принципу 
        - область видимости имеет доступ ко всем переменным объявленным выше по иерархии вложенности, 
        но не может получить доступ к переменным объявленным во вложенных областях видимости.</p>
    <p>Создадим несколько областей видимости и дадим им имена для наглядности.</p>
    <img src="./img/scopes.jpg" alt="">
    <ul>
        <li>Глобальная есть по умолчанию, создадим в ней переменную global</li>
        <li>Далее используя оператор if создадим блочную область видимости block A</li>
        <li>Внутри области видимости block A поставим еще один оператор if, 
            который создаст вложенную область видимости block B</li>
        <li>На одном уровне с block A, создадим область видимости block C все так же используя оператор if</li>
    </ul>
<img src="./img/scope1.jpg" alt="">
<img src="./img/scope2.jpg" alt="">
<img src="./img/scope3.jpg" alt="">
<img src="./img/scope4.jpg" alt="">

<h1>ЦИКЛЫ</h1>
<h2>1. Введение</h2>
<p>Частая задача программирования - выполнение однотипного действия много раз. 
    Например вывести клиентов из списка один за другим, или перебрать суммы зарплат 
    и для каждой выполнить одинаковый код. Именно для таких целей, многократного повторения одного участка кода, 
    используются циклы.</p>
<ul>
    <li>Цикл — управляющая конструкция в высокоуровневых языках программирования, 
        предназначенная для организации многократного исполнения набора инструкций.</li>
    <li>Тело цикла — последовательность инструкций, предназначенная для многократного исполнения.</li>
    <li>Итерация — единичное выполнение тела цикла.</li>
    <li>Условие выхода — выражение, определяющее будет в очередной раз выполняться итерация, или цикл завершится.</li>
    <li>Счётчик — переменная, хранящая текущий номер итерации. Цикл не обязательно содержит счётчик, 
        и он не обязан быть один, условие выхода из цикла может зависеть 
        от нескольких изменяемых в цикле переменных.</li>
</ul>
<p>Исполнение любого цикла включает:</p>
<ul>
    <li>первоначальную инициализацию переменных цикла</li>
    <li>проверку условия выхода</li>
    <li>исполнение тела цикла</li>
    <li>обновление переменной цикла на каждой итерации</li>
</ul>
<p>Кроме того, большинство языков программирования предоставляют средства управления циклом, 
    например, операторы завершения цикла, то есть выхода из цикла независимо от истинности условия выхода.</p>

    <h2>2. Цикл while</h2>
    <p>Цикл с предусловием — цикл, который выполняется пока истинно некоторое условие, указанное перед его началом. 
        Это условие проверяется до выполнения тела цикла, поэтому тело может быть не выполнено ни разу, 
        если условие с самого начала ложно.</p>
    <p>Другими словами: Инструкция while создает цикл, который выполняет блок кода, 
        пока условие проверки оценивается как true.</p>
    <p>while (expression) {          <br>
        // код, тело цикла (statement)          <br>
      }</p>
    <ul>
        <li>Оператор while вычисляет expression перед каждой итерацией цикла.</li>
        <li>Если expression оценивается как true, оператор while выполняет statement.</li>
        <li>Если expression оценивается как false, выполнение цикла прерывается и скрипт продолжает выполнять инструкции после цикла while.</li>
    </ul>
    <p>Блок-схема иллюстрирует цикл while.</p>
    <img src="./img/while.jpg" alt="">
    <p>Сделаем счетчик.</p>
    <p>let counter = 0;                                                <br>
                                                <br>
        while (counter < 10) {                                                <br>
          console.log('counter: ', counter);                                                <br>
          counter += 1;
        }</p>
    <p>Будем заполнять места в отеле до тех пор пока текущее количество клиентов не будет равно максимально допустимому.</p>
    <p>let clientCounter = 18;                                             <br>
        const maxClients = 25;                                             <br>
                                                     <br>
        while (clientCounter < maxClients) {                                             <br>
          console.log(clientCounter);                                             <br>
          clientCounter += 1;                                             <br>
        }                                             <br>
        </p>

    <h2>3. Цикл do...while</h2>
    <p>Цикл с постусловием — цикл, в котором условие проверяется после выполнения тела цикла. Отсюда следует, что тело всегда выполняется хотя бы один раз.</p>
    <p>Другими словами: Оператор do...while создает цикл, который выполняет блок кода до тех пор, пока expression не станет равным false.</p>
    <p>В отличие от цикла while, цикл do...while всегда выполняет statement как минимум один раз, прежде чем он оценит expression.</p>
    <p>do {                               <br>
        // statement                               <br>
      } while (expression);</p>
    <p>Внутри цикла нужно внести изменения в некоторую переменную, чтобы убедиться, что выражение равно false после итераций. В противном случае будет бесконечный цикл.</p>
    <img src="./img/do-while.jpg" alt="">
    <p>let password = '';                                         <br>
                                         <br>
        do {                                         <br>
          password = prompt('Введите пароль длиннее 4-х символов', '');                                         <br>
        } while (password.length < 5);                                         <br>
                                                 <br>
        console.log('Ввели пароль: ', password);
        </p>

    <h2>4. Цикл for</h2>
    <p>Цикл со счётчиком — цикл, в котором некоторая переменная изменяет своё значение от заданного начального до конечного значения, с некоторым шагом, и для каждого значения этой переменной тело цикла выполняется один раз.</p>
    <p>В большинстве процедурных языков программирования реализуется оператором for, в котором указывается счётчик, требуемое количество итераций и шаг, с которым изменяется счётчик.</p>
    <p>for (initialization; condition; post-expression) {               <br>            
        // statements           <br>           
      }</p>
    <p>Алгоритм исполнения цикла for:</p>
    <ul>
        <li>Инициализация (initialization) — выражение инициализации выполняется один раз, когда начинается цикл. Используется для инициализации переменной-счетчика. Если используется ключевое слово let, переменная счетчика является локальной для цикла.</li>
        <li>Условие (condition, test) — выражение, оцениваемое перед каждой итерацией цикла. Тело цикла выполняется только тогда, когда выражение условия принимает значение true. Цикл завершается, если значение будет false.</li>
        <li>Тело (statements) — выполняется в случае удовлетворения условия.</li>
        <li>Пост-выражение (post-expression) — выполняется после тела на каждой итерации цикла, но перед проверкой условия. Используется для обновления переменной-счетчика.</li>
    </ul>
    <p>Переменные-счетчики, по традиции, называются буквами i/j/k.</p>
    <p>const max = 10;                            <br>
                            <br>
        for (let i = 0; i < max; i += 1) {                            <br>
          console.log(i);                            <br>
        }
        </p>
    <p>Посчитаем сумму чисел до определенного значения.</p>
    <p>const target = 3;                                         <br>
        let sum = 0;                                         <br>
                                                 <br>
        for (let i = 0; i <= target; i += 1) {                                         <br>
          sum += i;                                         <br>
        }                                         <br>
                                                 <br>
        console.log(sum);
        </p>
    <p>Вспомним про операцию a % b и выведем остаток от деления используя цикл.</p>
    <p>const max = 10;                        <br>
                        <br>
        for (let i = 0; i < max; i += 1) {                        <br>
          console.log(`${max} % ${i} = `, max % i);                        <br>
        }
        </p>

    <h2>5. Инструкции break и continue</h2>
    <h3>5.1. break</h3>
    <p>Выйти из цикла можно не только при проверке условия, но и вообще в любой момент. Эту возможность предоставляет инструкция break. Она полностью прекращает выполнение цикла и передаёт управление на строку за его телом.</p>
    <p>Специально прервем цикл на 5-й итерации.</p>
    <p>for (let i = 0; i < 10; i += 1) {                                      <br>
        if (i === 5) {                                      <br>
          console.log('Дошли до 5-й итерации, прерываем цикл!');                                      <br>
          break;                                      <br>
        }                                      <br>
      }</p>

      <h3>5.2. continue</h3>
      <p>Директива continue прерывает не весь цикл, а только выполнение текущей итерации. Её используют, если понятно, что на текущей итерации цикла делать больше нечего или вообще ничего делать не нужно и пора переходить на следующую итерацию.</p>
      <p>/*                                  <br>
        * Используем цикл для вывода только нечетных чисел.                                  <br>
        * Для чётных i срабатывает continue, выполнение тела прекращается                                  <br>
        * и управление передаётся на следующую итерацию.                                  <br>
        */                                  <br>
       const number = 10;                                  <br>
                                         <br>
       for (let i = 0; i < number; i += 1) {                                  <br>
         if (i % 2 === 0) {                                  <br>
           continue;                                  <br>
         }                                  <br>
                                         <br>
         console.log('Нечетное i: ', i); // 1, 3, 5, 7, 9                                  <br>
       }</p>
    
    




    <!-- <script src="./js/task1.js" type="module"></script> -->
    <!-- <script src="./js/task2.js" type="module"></script> -->
    <!-- <script src="./js/task3.js" type="module"></script> -->
    <!-- <script src="./js/task4.js" type="module"></script> -->
    <script src="./js/task5.js" type="module"></script>
    <!-- <script src="js/example.js" type="module"></script> -->
</body>
</html>