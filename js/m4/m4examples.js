'use strict'
//тут очень много для собеседования

//CALLBACK Функции
//Функия высшего порядка - принимает в качестве параметров другие функции
// или возвращает функцию как результат

//пример самой обычной функции
const fn = function(a) {
    console.log(a)
}
fn(5); //5

//пример функции высшего порядка
const fn1 = function(a) {
    return function() {}
}
//или если при вызове она ожидает значение другой функции
// const fn1 = function(a) {
//     a();//т.е. в этот а придёт другая ф-ция и её можно будет вызвать
// }
// fn1(function() {});//а это callback ф-ция
//это та ф-ция, которая передаётся внутрь другой ф-ции



//вот например есть ф-ция
// const greet = function(name) {
//     console.log(`Hello ${name}`);
// };
// greet('Leo'); //Hello Leo

//а теперь сделаем функцию в которую передадим другую функцию
const greet = function(name) { 
    console.log(`Hello ${name}`);
}; //тут мы объявили ф-цию
//потом передали ссылку в greetWithName(greet); 
//она дошла в параметр (callback) в function(callback)
//и когда мы вызываем callback(name); то на самом деле вызывается
//ф-ция function(name).
//в неё (`Hello ${name}`); передаём callback(name); который const name = 'Leo';
//и видим Hello Leo. это концепция callback-ф-ции

const greetWithName = function(callback) { //тут говорится "передай мне сюда callback"
//мы передаем туда greet в greetWithName(greet);
//и фактически он вызывается в callback(name);
    const name = 'Leo';
    console.log(callback);
    callback(name);//вызов ф-ции greet внутри callback
};

greetWithName(greet); //Hello Leo
//т.е. function(name) это обычное значение, которое записали в переменную greet
//потом во время вызова greetWithName передаем в неё НЕ вызов ф-ции greet
//а просто ссылку на неё. получается в параметр callback записывается
//ссылка на function(name) {console.log(`Hello ${name}`);};
//т.е. если сделать console.log(callback); то там будет лежать эта ф-ция
    
//ф-ция необходима для того чтобы закрыть в ней какой-то функционал,
//не выполняя его сразу. и потом когда-то при необходимости
//вызвать эту ф-цию, т.е. выполнить её тело
//получется ф-ция это единственный вариант в JS отложить выполнение кода 

const handleButtonClick = function (){
    console.log('click');
};
//как пример когда у нас есть кнопка, и мы вешаем на неё слушатель события "клик"
//слушатель события это как раз ф-ция
// buttonref.addEventListener('click', handleButtonClick); //при клике в консоли будет 'click'
//addEventListener - ф-ция высшего порядка, которая первым аргументом
//принимает тип события - 'click', а вторым она говорит "дай мне ф-цию",
//которую я вызову с наступлением этого события 
//- это и есть callback ф-ция, т е ф-ция обратного вызова

//далее ассинхронный JS (для работы с серверами и т.п.)
setTimeout(function() {
    console.log('Запоздалый текст!');
}, 3000); //тут мы 1-м аргументом передаем callback, а вторым время через
//которое она должна вызваться
//подробнее на 12-й минуте вебинара


//про отложенный HTTP-запрос на 14-й минуте занятия 7 (это тоже callback)



//контекст выполнения (стэки вызовов) данных 23:30 занятие 7
//сцуко пересмотреть 20 раз



// 2. Лексическое окружение 33:20
//Это внутренняя стр-ра, скрытый механизм, который контролирует то,
//где и какая из функций какие переменные видит
//т.е. какие из переменных в каких областях видимости доступны
 //Это чем-то похоже на объект

//когда начинает выполняться скрипт делаетлся глобальное лексическое окружение
/*Global env 
    Record: {}
    Parent: null
*/
//оно создается при вызове. Record пустой потому что мы еще не делали переменных
const x = 10;
/*Global env 
    Record: {х: 10}
    Parent: null
*/
const y = 20;
/*Global env 
    Record: {х: 10, y: 20}
    Parent: null
*/
/* после чего интерпретатор встречает объявление ф-ции, ниже.
Лексическое окружение при объявлении ф-ции не создается, но при этом
этой ф-ции надо знать кто будет ее родительским лексическим окружением.
Эта ф-ция стоит в Global env, значит Global env  будет ее лекс окруж - родителем 
*/
const foo = function(z) {
    /* Foo env - создается в момент вызова ф-ции
        Record: {z: 30}
        Parent: Global env //потому что [[Enviroment]]
    */
    const x = 100;
/* Foo env - создается в момент вызова ф-ции
        Record: {z: 30, x: 100}
        Parent: Global env 
    */
    return x + y + z; 
    /*return берет значения из текущего лексического окр-я. если запрашиваемых
    значений нет в текущем, например y, то он пользуется ссылкой на Global env
    и берет ее оттуда
    И даже если y будет записан ниже объявления ф-ции, но при этом не 
    ниже вызова ф-ции ф-ция все равно его найдет*/
};
/*Записывается в момент объявления ф-ции, это выше
[[Enviroment]] = Global env 
Тем самым в момент объявление ф-ции, ей присваивается св-во Enviroment
в которое записывается ссылка на родительское лекс окр 
*/
/*Global env 
    Record: {х: 10, y: 20, foo: <function>}
    Parent: null
*/

console.log(foo(120)); //150
//результат 150 потому что в области видимости ф-ции объявлен х=100
// поэтому 100+20+30 = 150
/*а вот после этого foo(30); у ф-ции создается лексическое окружение
для каждого вызова ф-ции свое лексическое окружение
*/



//3. Замыкания  (50:00 занятие 7)
/*Замыкание (closure) - связь между ф-ей и её цепочкой областей видимости
Это механизм */
const fooo = function() {
    const x = 5;

    return function() {
        console.log(x);
    };
};
/* 
Если я вызову ф-цию fooo, то в переменную, в которую я запишу её результат
я  получу ф-цию return function ()*/
const outerFn = fooo();//когда это происходит интерпрет-р все бросает и начинает выполнять ф-цию
console.log(outerFn); //function() {console.log(x);};
//т.е. в outerFn записывается function() {console.log(x);};
outerFn(); // 5
/* x = 5 лежит во внешней обл видимости для ф-ции function() {console.log(x);};
т.е. эта ф-ция запомнила всё лекс окр fooo - 
это как раз и есть замыкание (лексического окружения)*/
//т.е. это когда ты берешь значение одной ф-ции и вызываешь в другой ф-ции

//на 54-й минуте подробный разбор


//еще пример
// const makeDish = function(sheffName, dish) {
//     console.log(`${sheffName} готовит ${dish}`);
// };

// makeDish('Mango', 'пирожок')
// makeDish('Mango', 'омлет')
// makeDish('Mango', 'чай')

// makeDish('Poly', 'котлеты');
// makeDish('Poly', 'супчик');
// makeDish('Poly', 'кофе');
//для того чтобы не вводить имя повара каждый раз поможет замыкание
//для этого делаем ф-цию
const makeSheff = function(name) {
    return function(dish) {
        console.log(`${name} готовит ${dish}`);
    };
};

const mango = makeSheff('Mango');
const poly = makeSheff('Poly');

mango('салат');
poly('компот');

//ф-ция function(dish) {console.log(`${name} готовит ${dish}`);};
//запомнила локальную переменную function(name)
//и когда мы makeSheff вернули в переменную mango и вызвали ее mango('салат');
//она получила function(dish) и во время console.log(`${name} готовит ${dish}`);
//она помнит, что ${name} это то что мы передавали в переменную const mango = makeSheff('Mango');

//чтобы проверить ф-ю на замыкание надо написать console.dir(mango)
//и в консоли развернуть вкладку Scopes


//АБСТРАКТНЫЙ ПРИМЕР ГЛУБОКОГО ЗАМЫКАНИЯ
const fnA = function(a){
    return function fnB (b){
        return function fnC(c){
            console.log(a,b,c);
        };
    };
};
const res = fnA(5)(10);
res(15); // 5 10 15


//СТОИТ РАЗОБРАТЬ ПРИМЕРЫ КОДА ИЗ КОНСПЕКТА





//ЗАНЯТИЕ 8 ЗАНЯТИЕ 8 ЗАНЯТИЕ 8 ЗАНЯТИЕ 8 ЗАНЯТИЕ 8 ЗАНЯТИЕ 8 
//контекст вызова функции

//Функция это частный случай объекта - ссылочный тип (функция это значение, а тип у нее - объект)

console.log('[] === []: ', [] === []); // false
console.log('{} === {}: ', {} === {}); // false
console.log(
    'function() {} === function() {}: ',
    function() {} === function() {},
); // false  потому что это 2 разные ссылки в памяти

/*ВАЖНО!!!!!
Два объекта могут быть равны только тогда когда мы сравниваем 2 переменные
в которых лежит ссылка на один и тот же объект. Поэтому смотрим ниже*/
//Мы созадим ф-цию и запишем в переменную
const fnC = function() {
    console.log('hello');
};
const fnD = fnC //тут в переменную fnD записываем ссылку на fnC
console.log('fnD === fnC: ', fnD === fnC); //true

//это было повторение ссылочных типов


//КОНТЕКСТ ИСПОЛНЕНИЯ
/*Ключевое слово this  которое есть внутри каждой ф-ции.
Контекст JS это как контекст внутри предложения.
Пример: // Петя бежит быстро, потому что Петя пытается поймать поезд.
const petya = {
  name: 'Petya',
  showName() {
    console.log(petya.name); это повторение, это нехорошо
  },
};

petya.showName();

Альтернатива: // Петя бежит быстро, потому что он (this) пытается поймать поезд.
const petya = {
  name: 'Petya',
  showName() {
    console.log(this.name);
  },
};

petya.showName();

Вот пример контекста this. Потому что Петя это то о чем это предложение.
*/

//Вызов в контексте объекта
const user = {
    tag: 'Leo',
    showTag() { //есть ф-ция showTag как метод объекта user
        //это называется вызов в контексте объекта
        console.log('this: ', this); //this:  {tag: "Leo", showTag: ƒ}
        console.log('this.tag: ', this.tag);//this.tag:  Leo
    },
};
//когда мы объявляли ф-цию, мы не знали что будет лежать в this
//просто указали, что будет контекст
//а потом когда интерпретатор дошел до строки ниже с вызовом ф-ции
//он увидел, что она вызывается в контексте объекта user
user.showTag();
/* в данном случае вызывает объект user, и поэтому this получит ссылку на
объект user
т.е. для this контекст присваивается в момент вызова showTag объектом user
именно именно поэтому this показывает значение user, а this.tag
значение tag объекта user*/


//ВЫЗОВ БЕЗ КОНТЕКСТА
const fn5 = function() {
    console.log('this: ', this);
};

foo(); //undefined
//если вызов без контекста привязки в объекту и в строгом режиме
//то будет undefined
//если вызвать в не строгом режиме, то будет ссылка на Window глобальное окно


//Вызов с контекстом, но когда ф-ция объявляется вне объекта
const showTag1 = function() {
    console.log('this: ', this);
    console.log('this.tag: ', this.tag);
};//ф-ция объявлена вне объекта

const user1 = {
    tag: 'Mango',
};
user1.fn = showTag1;//но тут она присваивается как св-во объекта

console.log(user1);
user1.fn();//и тут вызывается в контексте объекта
//т.е. в св-ве fn объекта user1 лежит ссылка на ф-ию showTag1
//и эта ф-ция showTag1 вызывается через св-во fn в контексте user1 - user1.fn();


//Вызов без контекста, но обявлена как метод объекта
const user2 = {
    tag: 'Poly',
    showTag2() {
        console.log('this: ', this);
        console.log('this tag: ', this.tag);
    },
};

const outerShowTag = user2.showTag2;

console.log(outerShowTag);

// outerShowTag(); //будет ошибка. не важно как она объявлена. важно как ее вызвали


// Вызов ф-ции в контексте другой ф-ции
const fn4 = function() {
    console.log('Heelo');
};
fn4.method = function() {
    console.log('this: ', this);
};
fn4.method(); //выдаст его this
//но это достаточно бесполезно


/*==========================================*/


//контекст callback ф-ции
//18-я минута

//ЗАДАЧКА А-ЛЯ на собеседовании
//что не так?
//тут происходит вызов ф-ции makeChangeColor(); в const changeColor = makeChangeColor();
//внутри неё создаётся ф-ция changeColor, в которой есть какой-то this
const makeChangeColor = function () {
    const changeColor = function(color) {
        this.color = color;
    };

    const sweater = {//дальше создается объект
        color: 'teal',
    };

    sweater.changeColor = changeColor;//этому объекту sweater в его св-во .changeColor
    //записывается ссылка на ф-цию changeColor
    //после чего мы возвращаем ссылку на метод объекта sweater.changeColor
    //т.е. то же самое, что ссылку на ф-цию changeColor 
    return sweater.changeColor;

};
//получается что в переменной ниже лежит тело ф-ции changeColor
const changeColor = makeChangeColor();
// changeColor('blue'); //будет undefined, потому что без контекста


/*======================================*/
//еще пример
const makeChangeColor1 = function () {
    const changeColor1 = function(color1) {
        console.log(this);
        this.color1= color1;
    };
    return changeColor1;
};

const hat = {
    color1: 'blue',
    changeColor1: makeChangeColor1(),
};
hat.changeColor1('orange'); //тут все хорошо и цвет меняется
console.log(hat);


//===============================================
//CALL-APPLY-BIND
/* Ф-ция - это объект, и у каждой ф-ции есть ещё свои методы,
т.е. свои ф-ции - CALL-APPLY-BIND.
Они служебные. Позволяют вызвать ф-цию в контексте какого-то объекта
не присваивая её никуда, т.е. не делая её методом этого объекта.*/
//Зачем это нужно?
const showTag3 = function(arg1, arg2, arg3) {
    console.log(arg1, arg2, arg3);
    console.log('this: ', this);
    console.log('this.tag: ', this.tag);
};
const cofe = {
    tag: 'Cofe',
};
const tea = {
    tag: 'Tea',
};

showTag3.call(cofe, 1, 2, 3); //1 2 3  this.tag:  Cofe
//метод call вызывает функцию прям на месте
// showTag3.call(tea, 5,10,15); //5 10 15  this.tag:  Tea
//и то, что мы передадим первым агрументом, например (cofe) оно и будет
//this для этой ф-ции

//метод apply делает почти то же самое, только передает аргументы в виде массива
showTag3.apply(cofe, [5,10,15]);//результат как в call

//эти 2 метода не используются в повседневной разработке
//используются для вызовов методов массивов, например у arguments вызвать splice
//иногда при написании библиотек

//метод BIND - не вызывает ф-цию прямо сейчас, оно берет вызываемую ф-цию
//создает её копию и возвращает на место вызова
//т.е. результат Bind можно записать в переменую, навсегда привязав ее контект 
//в этой переменной, и вызывать её без контекста 
//метод Bind берет ф-цию showTag3 и возвращает на место showTag3.bind();
//затем, что к копии ф-ции прикрепляется контекст навсегда
//т.е. привязка по факту это bind(cofe);

const showCofeTag = showTag3.bind(cofe);

showCofeTag(1,2,3);//ф-ция вызвана без привязки к контексту, но в ее this лежит cofe
//showCofeTag это ссылка на копию ф-ции с навсегда привязанным контекстом

//инфо зачем это и где юзается на 41-й минуте занятия 8
//в кратце это для callback, когда метод объекта кидаем как callback
//у метода необходимо привязать контекст, иначе не сработает

//ПРО ДОМАШКУ на 49 минуте