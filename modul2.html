<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2 Module Java Script</title>
</head>
<body>
<h1>1. Массивы</h1>
<p>Массив — структура данных для хранения и манипулирования коллекцией индексированных значений. 
    Используются для хранения упорядоченных коллекций данных, например списка курортов, товаров, 
    клиентов в отеле и т. п.</p>
<h2>2. Создание</h2>
<p>Синтаксис для создания нового массива — квадратные скобки [] со списком элементов разделенных запятыми. 
    В массиве может храниться любое число элементов любого типа.</p>
<p>// Пустой массив                                                     <br>
    const arr = [];                                                     <br>
                                                         <br>
    // Массив clients с тремя элементами                                                     <br>
    const clients = ['Mango', 'Poly', 'Ajax'];                                                     <br>
                                                         <br>
    console.log(clients); // ["Mango", "Poly", "Ajax"]</p>
<h2>3. Доступ к элементам</h2>
<p>В качестве ключей-индексов используются цифры, индексация начинается с нуля.</p>
<img src="./img/indices.jpg" alt="">
<p>Чтобы получить нужный элемент из массива, после имени переменной которая содержит массив, 
    указывается индекс элемента в квадратных скобках. На место такого выражения будет 
    подставлено значение хранящееся в элементе массива.</p>
<p>const clients = ['Mango', 'Poly', 'Ajax'];                         <br>
                         <br>
    // Указывая в скобках индекс элемента мы получаем его значение                         <br>
    console.log(clients[0]); // Mango                         <br>
    console.log(clients[1]); // Poly                         <br>
    console.log(clients[2]); // Ajax
    </p>

<h2>4. Переопределение</h2>
<p>Элементы массива можно заменять и добавлять, обращаясь к элементу массива по индексу.</p>
<p>const clients = ['Mango', 'Poly', 'Ajax'];                                           <br>
                                           <br>
    // Значение элемента можно заменить                                           <br>
    clients[0] = 'Kiwi';                                           <br>
    console.log(clients[0]); // Kiwi                                           <br>
                                               <br>
    // Или добавить                                           <br>
    clients[3] = 'Alex';                                           <br>
    console.log(clients[3]); // Alex                                           <br>
                                               <br>
    console.log(clients); // ["Kiwi", "Poly", "Ajax", "Alex"]
    </p>

<h2>5. Длина массива</h2>
<p>Длина массива динамическая величина и изменяется автоматически при добавлении или удалении элементов. 
    Текущее число элементов массива содержится в его свойстве length.</p>
<p>Свойство length можно изменять напрямую.</p>
<ul>
    <li>Если установить для свойства length значение, превышающее количество элементов в массиве, 
        новые элементы будут добавлены с начальными значениями undefined.</li>
    <li>Если задать длину массива меньше чем текущее кол-во элементов в массиве 
        то все "не влезшие" элементы в новую длину просто удаляются.</li>
</ul>
<img src="./img/massive_lengh.jpg" alt="">


<h2>6. Итерация по массиву</h2>
<p>Для итерации по массиву или перебора массива, используются циклы, в частности цикл for. 
    Переберем массив клиентов и выведем их имена.</p>
<p>const clients = ['Mango', 'Ajax', 'Poly'];                          <br>
                          <br>
    for (let i = 0; i < clients.length; i += 1) {                          <br>
      console.log('Logging clients: ', clients[i]);                          <br>
    }
    </p>
<p>С помощью цикла массив можно заполнить данными.</p>
<p>const numbers = [];                   <br>
                   <br>
    for (let i = 0; i < 3; i += 1) {                   <br>
      numbers.push(`label-${i}`);                   <br>
    }                   <br>
                       <br>
    console.log('numbers: ', numbers); // ['label-0', 'label-1', 'label-2']</p>

<h2>6.1. Цикл for...of</h2>
<p>Инструкия for...of создает цикл, перебирающий итерируемые объекты, такие как массивы и строки. 
    Тело цикла будет выполняться для значения каждого отдельного элемента. 
    Это хорошая замена циклу for если не нужен доступ к счетчику итерации.</p>
<p>for (const variable of iterable) {      <br>
    // statement      <br>
  }
  </p>
<ul>
    <li>variable — для каждой итерации значение свойства присваивается переменной.</li>
<li>iterable — коллекция, которая имеет перечислимые свойства.</li>
</ul>
<p>// Итерация по массиву                   <br>
    const clients = ['Mango', 'Ajax', 'Poly'];                   <br>
                       <br>
    for (const client of clients) {                   <br>
      console.log(client);                   <br>
    }                   <br>
    
    // Итерация по строке                   <br>
    const string = 'javascript';                   <br>
                       <br>
    for (const character of string) {                   <br>
      console.log(character);                   <br>
    }</p>

    <h2>6.2. Инструкции break и continue</h2>
    <p>Будем искать имя клиента в массиве имен, если нашли прервем цикл 
        так как нет смысла искать дальше, имена у нас уникальные.</p>
    <img src="./img/massive_break.jpg" alt="">
    <p>Можно изначально задать message значение неудачи поиска, а в цикле перезаписать его на успех если нашли имя. 
        Но break всеравно пригодится, так как если у нас массив из 10000 клиентов а нужный нам стоит на позиции 2, 
        то нет абсолютно никакого смысла перебирать оставшиеся 9998 элементов.</p>
    <img src="./img/masive_break2.jpg" alt="">
    <p>Используем цикл для вывода только чисел больше определенного значения.</p>
    <img src="./img/cycle.jpg" alt="">
    
    <h2>7. Многомерные массивы</h2>
    <p>Массивы могут содержать другие массивы как элементы. Это можно использовать для создания матриц.</p>
    <img src="./img/matrix1.jpg" alt="">
    <p>Для того чтобы перебрать такой массив используются вложенные циклы.</p>
    <img src="./img/matrix2.jpg" alt="">



    <h1>1. Присвоение по ссылке и по значению</h1>
    <p>Фундаментальным отличием сложных типов от примитивов, является то, как они хранятся и копируются.</p>
    <p>Примитивы: строки, числа, були,null и undefined, при присваивании копируются целиком, по значению (by value).</p>
    <p>Со сложными типами всё не так. В переменной, которой присвоен массив или объект, хранится не само значение, 
        а адрес его места в памяти, иными словами — ссылка (указатель) на него, 
        и передаются они по ссылке (by reference).</p>
    <p>Представим переменную в виде листа бумаги. Значение этой переменной мы представим в виде записи на этом листе.</p>
    <img src="./img/original.jpg" alt="">
    <p>Если мы захотим сообщить содержимое этой записи пользователям то мы можем поступить так — 
        сделать физические копии и вручить их каждому, 
        то есть сделать множественные независимые копии (присвоение по значению).</p>
    <img src="./img/by-value.jpg" alt="">
    <p>Или поместить лист в закрытой комнате и дать пользователям ключ от этой комнаты, 
        то есть 1 экземпляр с общим доступом (присвоение по ссылке).</p>
    <img src="./img/by-reference.jpg" alt="">
    <p>Теперь изменим данные на листе бумаги, значение переменной. 
        Очевидно, что посетители комнаты всегда будут видеть изменения которые мы вносим, 
        так как изменяется оригинал и они имеют доступ к нему доступ. 
        И также очевидно, что владельцы бумажных копий не заметят изменений глядя на свои копии.</p>
    <img src="./img/full.jpg" alt="">
    <p>При передаче по значению, переменным выделяется новая ячейка памяти и в нее копируется данные. 
        Аналогия с множественными копиями бумажного листа имеет вполне реальное воплощение, 
        отдельный лист для каждой копии.</p>
    <p>При передаче по ссылке, вместо создания нового объекта, переменной присваивается ссылка (указатель) 
        на уже существующий объект, то есть на его место в памяти. Таким образом несколько переменных 
        могут указывать на один и тот же объект, по аналогии с закрытой комнатой, у них есть 
        ключ доступа к оригиналу листа.</p>
    <b>Все примитивные типы присваиваются по значению, то есть создается копия.</b>
    <img src="./img/copy.jpg" alt="">
    <p>Сложные типы - объекты, массивы, функции присваиваются по ссылке, 
        то есть переменная просто получает ссылку на уже существующий объект.</p>
    <img src="" alt="">

    <h1>МЕТОДЫ МАССИВА</h1>
    <h2>1. Методы split() и join()</h2>
    <p>split(s) — позволяет превратить строку в массив, разбив ее по разделителю s. 
        Это не метод массива, но рассматриваем мы его сейчас так как раньше мы о массивах не знали.</p>
    <p>join(s) — делает в точности противоположное split. 
        Он берет массив и склеивает его в строку, используя s как разделитель.</p>
    <img src="./img/join_split.jpg" alt="">
    <h2>2. Методы indexOf() и includes()</h2>
    <p>array.indexOf(x) — возвращает первый индекс, в котором элемент x был найден в массиве, 
        или число -1, если такого элемента нет. Используйте indexOf тогда, 
        когда необходимо получить непосредсвенно индекс элемента.</p>
    <img src="./img/indexof.jpg" alt="">
    <p>array.includes(x) — определяет, содержит ли массив некоторый элемент x, 
        возвращая true или false соответственно. Используйте includes тогда, 
        когда необходимо проверить есть ли элемент в массиве и не важен его порядковый номер.</p>
    <img src="./img/indices.jpg" alt="">
    <h2>2.1. Проверка множественных условий с includes()</h2>
    <p>На первый взгляд пример ниже выглядит вполне хорошо. 
        Однако, что если у нас будет больше красных фруктов, 
        к примеру ещё вишня (cherry) или клюква (cranberries)? 
        Будем ли мы расширять условие с помощью дополнительных ||?</p>
    <img src="./img/includes1.jpg" alt="">
    <p>Можем переписать условие, с использованием Array.includes, это очень просто и масштабируемо.</p>
    <img src="./img/includes2.jpg" alt="">
    








</body>
</html>