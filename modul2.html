<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2 Module Java Script</title>
</head>
<body>
    <h1>1. Массивы</h1>
    <p>Массив — структура данных для хранения и манипулирования коллекцией индексированных значений. 
        Используются для хранения упорядоченных коллекций данных, например списка курортов, товаров, 
        клиентов в отеле и т. п.</p>
    <h2>2. Создание</h2>
    <p>Синтаксис для создания нового массива — квадратные скобки [] со списком элементов разделенных запятыми. 
        В массиве может храниться любое число элементов любого типа.</p>
    <p>// Пустой массив                                                     <br>
        const arr = [];                                                     <br>
                                                            <br>
        // Массив clients с тремя элементами                                                     <br>
        const clients = ['Mango', 'Poly', 'Ajax'];                                                     <br>
                                                            <br>
        console.log(clients); // ["Mango", "Poly", "Ajax"]</p>
    <h2>3. Доступ к элементам</h2>
    <p>В качестве ключей-индексов используются цифры, индексация начинается с нуля.</p>
    <img src="./img/indices.jpg" alt="">
    <p>Чтобы получить нужный элемент из массива, после имени переменной которая содержит массив, 
        указывается индекс элемента в квадратных скобках. На место такого выражения будет 
        подставлено значение хранящееся в элементе массива.</p>
    <p>const clients = ['Mango', 'Poly', 'Ajax'];                         <br>
                            <br>
        // Указывая в скобках индекс элемента мы получаем его значение                         <br>
        console.log(clients[0]); // Mango                         <br>
        console.log(clients[1]); // Poly                         <br>
        console.log(clients[2]); // Ajax
        </p>

    <h2>4. Переопределение</h2>
    <p>Элементы массива можно заменять и добавлять, обращаясь к элементу массива по индексу.</p>
    <p>const clients = ['Mango', 'Poly', 'Ajax'];                                           <br>
                                            <br>
        // Значение элемента можно заменить                                           <br>
        clients[0] = 'Kiwi';                                           <br>
        console.log(clients[0]); // Kiwi                                           <br>
                                                <br>
        // Или добавить                                           <br>
        clients[3] = 'Alex';                                           <br>
        console.log(clients[3]); // Alex                                           <br>
                                                <br>
        console.log(clients); // ["Kiwi", "Poly", "Ajax", "Alex"]
        </p>

    <h2>5. Длина массива</h2>
    <p>Длина массива динамическая величина и изменяется автоматически при добавлении или удалении элементов. 
        Текущее число элементов массива содержится в его свойстве length.</p>
    <p>Свойство length можно изменять напрямую.</p>
    <ul>
        <li>Если установить для свойства length значение, превышающее количество элементов в массиве, 
            новые элементы будут добавлены с начальными значениями undefined.</li>
        <li>Если задать длину массива меньше чем текущее кол-во элементов в массиве 
            то все "не влезшие" элементы в новую длину просто удаляются.</li>
    </ul>
    <img src="./img/massive_lengh.jpg" alt="">


    <h2>6. Итерация по массиву</h2>
    <p>Для итерации по массиву или перебора массива, используются циклы, в частности цикл for. 
        Переберем массив клиентов и выведем их имена.</p>
    <p>const clients = ['Mango', 'Ajax', 'Poly'];                          <br>
                            <br>
        for (let i = 0; i < clients.length; i += 1) {                          <br>
        console.log('Logging clients: ', clients[i]);                          <br>
        }
        </p>
    <p>С помощью цикла массив можно заполнить данными.</p>
    <p>const numbers = [];                   <br>
                    <br>
        for (let i = 0; i < 3; i += 1) {                   <br>
        numbers.push(`label-${i}`);                   <br>
        }                   <br>
                        <br>
        console.log('numbers: ', numbers); // ['label-0', 'label-1', 'label-2']</p>

    <h3>6.1. Цикл for...of</h3>
    <p>Инструкия for...of создает цикл, перебирающий итерируемые объекты, такие как массивы и строки. 
        Тело цикла будет выполняться для значения каждого отдельного элемента. 
        Это хорошая замена циклу for если не нужен доступ к счетчику итерации.</p>
    <p>for (const variable of iterable) {      <br>
        // statement      <br>
    }
    </p>
    <ul>
        <li>variable — для каждой итерации значение свойства присваивается переменной.</li>
    <li>iterable — коллекция, которая имеет перечислимые свойства.</li>
    </ul>
    <p>// Итерация по массиву                   <br>
        const clients = ['Mango', 'Ajax', 'Poly'];                   <br>
                        <br>
        for (const client of clients) {                   <br>
        console.log(client);                   <br>
        }                   <br>
        
        // Итерация по строке                   <br>
        const string = 'javascript';                   <br>
                        <br>
        for (const character of string) {                   <br>
        console.log(character);                   <br>
        }</p>

    <h3>6.2. Инструкции break и continue</h3>
    <p>Будем искать имя клиента в массиве имен, если нашли прервем цикл 
        так как нет смысла искать дальше, имена у нас уникальные.</p>
    <img src="./img/massive_break.jpg" alt="">
    <p>Можно изначально задать message значение неудачи поиска, а в цикле перезаписать его на успех если нашли имя. 
        Но break всеравно пригодится, так как если у нас массив из 10000 клиентов а нужный нам стоит на позиции 2, 
        то нет абсолютно никакого смысла перебирать оставшиеся 9998 элементов.</p>
    <img src="./img/masive_break2.jpg" alt="">
    <p>Используем цикл для вывода только чисел больше определенного значения.</p>
    <img src="./img/cycle.jpg" alt="">
    
    <h2>7. Многомерные массивы</h2>
    <p>Массивы могут содержать другие массивы как элементы. Это можно использовать для создания матриц.</p>
    <img src="./img/matrix1.jpg" alt="">
    <p>Для того чтобы перебрать такой массив используются вложенные циклы.</p>
    <img src="./img/matrix2.jpg" alt="">



    <h1>1. Присвоение по ссылке и по значению</h1>
    <p>Фундаментальным отличием сложных типов от примитивов, является то, как они хранятся и копируются.</p>
    <p>Примитивы: строки, числа, були,null и undefined, при присваивании копируются целиком, по значению (by value).</p>
    <p>Со сложными типами всё не так. В переменной, которой присвоен массив или объект, хранится не само значение, 
        а адрес его места в памяти, иными словами — ссылка (указатель) на него, 
        и передаются они по ссылке (by reference).</p>
    <p>Представим переменную в виде листа бумаги. Значение этой переменной мы представим в виде записи на этом листе.</p>
    <img src="./img/original.jpg" alt="">
    <p>Если мы захотим сообщить содержимое этой записи пользователям то мы можем поступить так — 
        сделать физические копии и вручить их каждому, 
        то есть сделать множественные независимые копии (присвоение по значению).</p>
    <img src="./img/by-value.jpg" alt="">
    <p>Или поместить лист в закрытой комнате и дать пользователям ключ от этой комнаты, 
        то есть 1 экземпляр с общим доступом (присвоение по ссылке).</p>
    <img src="./img/by-reference.jpg" alt="">
    <p>Теперь изменим данные на листе бумаги, значение переменной. 
        Очевидно, что посетители комнаты всегда будут видеть изменения которые мы вносим, 
        так как изменяется оригинал и они имеют доступ к нему доступ. 
        И также очевидно, что владельцы бумажных копий не заметят изменений глядя на свои копии.</p>
    <img src="./img/full.jpg" alt="">
    <p>При передаче по значению, переменным выделяется новая ячейка памяти и в нее копируется данные. 
        Аналогия с множественными копиями бумажного листа имеет вполне реальное воплощение, 
        отдельный лист для каждой копии.</p>
    <p>При передаче по ссылке, вместо создания нового объекта, переменной присваивается ссылка (указатель) 
        на уже существующий объект, то есть на его место в памяти. Таким образом несколько переменных 
        могут указывать на один и тот же объект, по аналогии с закрытой комнатой, у них есть 
        ключ доступа к оригиналу листа.</p>
    <b>Все примитивные типы присваиваются по значению, то есть создается копия.</b>
    <img src="./img/copy.jpg" alt="">
    <p>Сложные типы - объекты, массивы, функции присваиваются по ссылке, 
        то есть переменная просто получает ссылку на уже существующий объект.</p>
    <img src="./img/copy1.jpg" alt="">

    <h1>МЕТОДЫ МАССИВА</h1>
    <h2>1. Методы split() и join()</h2>
    <p>split(s) — позволяет превратить строку в массив, разбив ее по разделителю s. 
        Это не метод массива, но рассматриваем мы его сейчас так как раньше мы о массивах не знали.</p>
    <p>join(s) — делает в точности противоположное split. 
        Он берет массив и склеивает его в строку, используя s как разделитель.</p>
    <img src="./img/join_split.jpg" alt="">
    <h2>2. Методы indexOf() и includes()</h2>
    <p>array.indexOf(x) — возвращает первый индекс, в котором элемент x был найден в массиве, 
        или число -1, если такого элемента нет. Используйте indexOf тогда, 
        когда необходимо получить непосредсвенно индекс элемента.</p>
    <img src="./img/indexof.jpg" alt="">
    <p>array.includes(x) — определяет, содержит ли массив некоторый элемент x, 
        возвращая true или false соответственно. Используйте includes тогда, 
        когда необходимо проверить есть ли элемент в массиве и не важен его порядковый номер.</p>
    <img src="./img/indices.jpg" alt="">
    <h3>2.1. Проверка множественных условий с includes()</h3>
    <p>На первый взгляд пример ниже выглядит вполне хорошо. 
        Однако, что если у нас будет больше красных фруктов, 
        к примеру ещё вишня (cherry) или клюква (cranberries)? 
        Будем ли мы расширять условие с помощью дополнительных ||?</p>
    <img src="./img/includes1.jpg" alt="">
    <p>Можем переписать условие, с использованием Array.includes, это очень просто и масштабируемо.</p>
    <img src="./img/includes2.jpg" alt="">
    
    <h2>3. Методы push(), pop(), shift(), unshift()</h2>
    <p>Добавляют или удаляют крайние элементы массива. 
        Работают только с крайним левым и крайним правым элементом массива, и не могут поставить 
        или удалить элемент с произвольной позиции. Для наглядности взягляните на иллюстрацию ниже.</p>
    <img src="./img/arr-methods.jpg" alt="">
    <h3>3.1. push и pop</h3>
    <p>push() — позволяет добавить один или несколько элементов в конец массива. 
        Метод возвращает значение свойства length, которое определяет количество элементов в массиве.</p>
    <img src="./img/push.jpg" alt="">
    <p>pop() — удаляет элемент из конца массива и возвращает удаленный элемент. 
        Если массив пуст, метод возвращает undefined.</p>
    <p>pop() — удаляет элемент из конца массива и возвращает удаленный элемент. 
        Если массив пуст, метод возвращает undefined.</p>
    <img src="./img/pop.jpg" alt="">
    <p>В примере кодом описаны иллюстрации выше, первые 3 шага. 
        Создается пустой массив с именем stack и в конец массива добавляется три числа, 
        одно за другим используя push(), затем они удаляются используя pop().</p>
    <img src="./img/push-pop.jpg" alt="">
    <h3>3.2. shift() и unshift()</h3>
    <p>Используются реже.</p>
    <ul>
        <li>shift() — удаляет элемент из начала массива и возвращает его (элемента) значение.</li>
        <li>unshift() — добавляет элемент в начало массива.</li>
    </ul>
    <img src="./img/shift-unshift.jpg" alt="">

    <h2>Метод slice()</h2>
    <p>Синтаксис метода slice() одинаков для строк и массивов. Его просто запомнить. 
        Он позволяет извлекать элементы подмножества массива и добавлять их в новый массив. 
        В большинстве случаев используется для создания копии части или целого исходного массива.</p>
    <b>slice(begin, end)    </b>
    <img src="./img/slice.jpg" alt="">
    <ul>
        <li>Оба аргумента ( begin и end) не обязательны.</li>
        <li>Параметр begin определяет индекс, с которого следует начинать извлечение.</li>
        <li>Параметр end, определяет индекс элемента, на котором следует закончить извлечение.
            Метод slice не включает элемент с идексом end в извлеченные элементы.
        </li>
        <li>Если begin и end не указаны, копирование будет с начала массива, с индекса 0, 
            - то есть скопируется весь массив.</li>
        <li>Если не указать параметр end, метод slice будет использовать длину массива (length) для параметра end.</li>
        <li>Метод slice не изменяет исходный массив, а возвращает новый массив, содержащий копию элементов исходного.</li>
        <li>Можно использовать отрицательные индексы, они отсчитываются с конца.</li>
    </ul>
    <img src="./img/slice1.jpg" alt="">

    <h2>Можно использовать отрицательные индексы, они отсчитываются с конца.</h2>
    <p>splice() — швейцарский нож для работы с массивами, в том случае, если исходный массив необходимо изменить. 
        Позволяет удалять, добавлять и заменять элементы в произвольном месте массива.</p>
    
        <h3>5.1. Удаление элементов массива</h3>
        <p>Чтобы удалить элементы в массиве, передаются два аргумента.</p>
        <b>splice(position, num)</b>
        <ul>
            <li>position — указывает позицию (индекс) первого элемента для удаления</li>
            <li>num — определяет количество удаляемых элементов</li>
        </ul>
        <p>Метод splice изменяет исходный массив и возвращает массив, содержащий удаленные элементы.</p>
        <img src="./img/splice.jpg" alt="">
        <p>На рисунке показан вызов метода score.splice(0, 3) из примера выше.</p>
        <img src="./img/splice-remove.jpg" alt="">
        
        <h3>5.2. Вставка элементов в массив</h3>
        <p>Вы можете вставить один или несколько элементов в массив, передав три или более аргумента методу splice, 
            при этом второй аргумент должен быть равен нулю.</p>
        <b>splice(position, 0, new_element_1, new_element_2, ...)</b>
        <ul>
            <li>Аргумент position указывает начальную позицию в массиве, 
                в которой будут вставлены новые элементы.</li>
            <li>Второй аргумент равен нулю 0, он говорит методу не удалять какие-либо элементы.            </li>
            <li>Третий, четвертый и все последующие аргументы — это новые элементы, 
                которые вставляются в массив.</li>
        </ul>
    
        <b>Обратите внимание, что метод splice изменяет исходный массив. 
            Кроме того, он не удаляет какие-либо элементы, поэтому в этом случае возвращается пустой массив.</b>
        <img src="./img/splice2.jpg" alt="">
        <p>На рисунке показан вызов метода colors.splice(2, 0, 'purple') из примера выше.</p>
        <img src="./img/splice-insert.jpg" alt="">

        <h3>5.3. Замена элементов массива</h3>
        <p>Метод splice() также позволяет вставить новые элементы в массив 
            при одновременном удалении существующих элементов.</p>
        <p>Для этого необходмо передать по крайней мере три аргумента: 
            вторым — количество элементов для удаления, а третим — элементы для вставки. 
            Количество удаляемых и добавляемых элементов может не совпадать.</p>
        <img src="./img/splice-change.jpg" alt="">
        <p>На рисунке показан вызов метода languages.splice(1, 1, 'Python') из примера выше.</p>
        <img src="./img/splice-replace.jpg" alt="">


    <h2>6. Метод concat()</h2>
    <p>Используется для объединения двух или более массивов. 
        Этот метод не изменяет исходный массив, а возвращает новый.</p>
    <img src="./img/concat.jpg" alt="">


    <h2>1. Понятие функции</h2>
    <p>Очень часто при создании программ участок кода повторяется. 
        А если программа большая, то возникает необходимость повторно использовать подобные участки кода, 
        зачастую с новыми начальными значениями. Воплощением этой идеи являются функции.</p>
    <p>Функция - это подпрограмма, независимая частью кода, предназначенная для выполнения конкретной задачи.</p>
    <p>Функции можно представить как черный ящик, они получают что-то на входе (данные), 
        и отдают что-то на выходе (результат выполнения кода внутри функции).</p>
    <img src="./img/fn-basics.jpg" alt="">
    <p>Функции это инструмент для структурирования больших программ, 
        уменьшения повторений и изолирования кода.</p>

    <h2>2. Функциональное выражение</h2>
    <p>Функциональное выражение (function expression) — 
        обычное объявление переменной, значение которой будет функция.</p>
    <p>Объявим переменную add, и присвоим ей функцию принимающую 3 значения 
         возвращающую результат сложения этих значений.</p>
        <p><b>ВАЖНО!</b>
            Имя функции это действие, глагол начинающийся с маленькой буквы, отвечающий на вопрос 'Что сделать?'. 
            Например: findSmallesNumber, fetchUserInfo, validateInput.</p>
        <img src="./img/fn.jpg" alt="">
    <p>Определение функции начинается с ключевого слова function, за которым может следовать 
        необязательное имя функции. В круглых скобках идут параметры — перечисление данных 
        которые функция будет получать из вне. Параметров может быть несколько, или вообще их может не быть, 
        тогда записываются просто пустые круглые скобки ().</p>
    <p>Далее идет тело функции, заключенное в фигурные скобки {}, содержащее инструкции 
        которые необходимо выполнить при вызове функции. Тело функции всегда заключают в фигурные скобки, 
        даже если оно состоит из одной инструкции.</p>
    <p>Оператор return определяет возвращаемое значение. Когда интерпретатор доходит до return, 
        он сразу же выходит из функции, и возвращает это значение в то место кода, где функция была вызвана.</p>
    <p><b>ВАЖНО!</b>
        Оператор return без выражения возвращает значение undefined. 
        При отсутствии return в теле функции, она все равно вернет значение undefined.</p>
    
    <p>Затем, когда необходимо, функция вызывается с помощью имени и круглых скобок, 
        внутри которых могут быть переданы аргументы.</p>
    <ul>
        <li>
            Термин аргументы используется при вызове функции, когда мы передаем значения в функцию.
        </li>
        <li>
            Термин параметры используется при объявлении функции, это те локальные переменные внутри функции, 
            в которые будут записаны значения аргументов во время ее вызова.
        </li>
    </ul>
    <p>В JavaScript важен порядок объявления параметров функции. 
        Не существует никакого другого механизма пояснить интерпретатору 
        как значения аргументов функции при вызове связаны с параметрами.</p>
    <p>Порядок объявления параметров соответствует порядку передачи аргументов при вызове функции: 
        значение первого аргумента будет присвоено первому параметру, второго аргумента второму параметру и т. д. 
        Если параметров будет меньше чем аргументов, то параметрам без значений будет присвоено undefined.</p>
    <img src="./img/fn1.jpg" alt="">
    <p>Функция может либо вызвать побочные эффекты (изменять глобальные переменные), 
        либо возвращать результат своей работы, зависит от задачи. 
        В зависимости от того, какой фрагмент кода будет помещен внутри функции, 
        произойдет либо возврат вычисленного значения, либо изменение состояния программы, иногда оба.</p>
    
    <h2>3. Порядок выполения кода</h2>
    <p>Если при выполнении кода, интерпретатор встречает вызов функции, 
        он приостанавливает выполнение текущего кода и начинает выполнять код из тела функции. 
        После того как весь код функции будет выполнен, интерпретатор выходит из тела функции, 
        возвращаясь в то место, откуда пришел, и продолжает выполнять код ниже вызова функции.</p>
    <img src="./img/fn2.jpg" alt="">
    <p>Пошагово разберем выполнение кода примера:</p>
    <ul>
        <li>При входе в js-файл, код начинает выполняться сверху вниз.</li>
        <li>Вызов fnA() заставляет интерпретатор приостановить исполнение кода, и зайти в тело функции fnA.</li>
        <li>В функции fnA интерпретатор встречает вызов функции fnB, 
            которая перехватывает контроль и исполняется.</li>
        <li>Как только интерпретатор выполнил функцию fnB, тоесть в ней произошел return, в нашем случае не явный, 
            интерпретатор возвращается в функцию fnA и продолжает выполнять ее с того места где остановился.</li>
        <li>Как только интерпретатор выполнил функцию fnA, тоесть в ней произошел return, в нашем случае не явный, 
            интерпретатор возвращается в глобальный код и продолжает его выполнение.</li>
    </ul>
    <b>Вызовы console.log(), так как это функция, тоже перехватывают контроль. 
        Они были пропущены для более понятного описания процесса.</b>
    
        <h2>4. Параметры по умолчанию</h2>
        <p>При вызове функции необязательно указывать значения всех аргументов, 
            которые перечислены в параметрах функции. Но иногда, параметрам 
            которым не передали значение через аргумент, бывает необходимо присвоить какое-то значение, 
            отличное от undefined.</p>
        <p>Новые возможности ES6 позволяют сделать это очень простым и очевидным образом, 
            указывая значение по умолчанию прямо при объявлении параметров в подписи функции. 
            При такой записи, если значение переданного аргумента равно undefined, 
            в параметр записывается значение по умолчанию.</p>
        <img src="./img/default.jpg" alt="">

        <h2>5. Псевдомассив arguments</h2>
        <p>Доступ к набору всех аргументов можно получить через специальную локальную переменную arguments, 
            которая доступна только внутри функции и хранит все аргументы как псевдомассив.</p>
        <p>Псевдомассив — коллекция, имеющая свойство length и возможность обратиться к элементу по индексу, 
            но отсутствием большинства методов для работы с массивом.</p>
        <p>Псевдомассив arguments содержит список аргументов, переданных функции при вызове, 
            но количество переданных аргументов может не совпадать с количеством объявленных параметров 
            и это не приведет к ошибке.</p>
        <p>Рассмотрим пример использования arguments в функции, которая суммирует любое количество аргументов:</p>
        <img src="./img/pseudo.jpg" alt="">

        <h3>5.1. Способы преобразовать псевдомассив</h3>
        <p>Так как у псевдомассива нету методов вроде slice() или includes(), 
            часто необходимо преобразовать его в полноценный массив. 
            На практике используют несколько основных способов преобразования.</p>
        <p>Используя метод Array.from(), который создаст массив из итерируемого объекта.</p>
        <img src="./img/arrayOf.jpg" alt="">
        <p>Используя операцию ... (rest), она позволяет собрать произвольное количество элементов, 
            в нашем случае аргументов, в массив и сохранить его в переменную. 
            Собираем все аргументы используя операцию rest прямо в подписи функции.</p>
        <img src="./img/rest.jpg" alt="">

        <h2>6. Паттерн Guard Clause</h2>
        <p>Оператор if...else это основной способ создания логических деревьев. 
            Тем не менее, сложные вложенные ветвления делают код более запутанным и трудным для понимания.</p>
        <p>Создадим функцию которая обрабатывает снятие денег с личного счета в банке. 
            Функция получает сумму для снятия и текущий баланс счета, после чего в зависимости от условия, 
            выполняет тот или иной блок кода.</p>
        <img src="./img/guard.jpg" alt="">
        <p>Даже в таком простом примере есть группа вложенных условных операторов, 
            среди которых не сразу можно выделить нормальный ход выполнения кода 
            из-за особенности синтксиса if...else.</p>
        <p><b>Паттерн guard clause</b> - это способ использовать возможность досрочного возврата из функции 
            с помощью оператора return, чтобы сделать вложенные условные выражения более одномерными.</p>
        <p>Выделим все проверки условий в отдельные операторы if, после чего добавим код идущий в теле else. 
            В идеальном случае, должен получиться плоский список условных операторов, идущих один за другим, 
            а в конце блок который выполнится только в том случае если не выполнится ни один if.</p>
        <p>const withdraw = function(amount, balance) {                                                                 <br>
                                                                            <br>
            if (amount === 0) {                                                                 <br>
              console.log('Для проведения операции введите сумму больше нуля.');                                                                 <br>
              return;                                                                 <br>
            }                                                                 <br>
                                                                         <br>
            if (amount > balance) {                                                                 <br>
              console.log('Недостаточно средств на счету.');                                                                 <br>
              return;                                                                 <br>
            }                                                                 <br>
            console.log('Операция снятия средств проведена.');                                                                 <br>
          };                                                                 <br>
                                                                           <br>
          withdraw(0, 300); // Для проведения операции введите сумму больше нуля.                                                                 <br>
          withdraw(500, 300); // Недостаточно средств на счету.                                                                 <br>
          withdraw(100, 300); // Операция снятия средств проведена.                                                                 <br>
          
            /*
            * Проверяется условие. Если оно выполняется, происходит
            * console.log и выход из функции. Код идущий после тела if
            * не выполнится.
            */
            /*
             * Если условие первого if не выполнилось, его тело пропускается
             * и интерпретатор доходит до этого if.
             * Проверяется условие. Если оно выполняется, происходит
             * console.log и выход из функции. Код идущий после тела if
             * не выполнится.
             */
            /*
             * Если ни один из предыдущих if не выполнился,
             * интерпретатор доходит до этого кода и выполняет его.
             */
            
          </p>
          <p>Используя такой подход получаем более чистый, плоский и понятный код, который легче рефакторить.</p>
        
          <h2>7. Объявление функции</h2>
          <p>Другой способ создать функцию — использовать ключевое слово function в начале инструкции. 
              Такая запись называется объявление функции (function declaration).</p>
            <p>Инструкция определяет переменную add и присваивает ей заданную функцию. Эта форма записи не требует 
                обязательной точки с запятой после закрытия фигурной скобки тела функции.</p>
            <img src="./img/declaration.jpg" alt="">
        <p>Особенностью этого синтаксиса является то, что функцию можно вызвать до ее объявления в коде. 
            Это может быть удобно, потому что не нужно беспокоиться о необходимости определять все функции выше того места, 
            где они используются. Механизм поднятия идентификаторов описан в следующей главе "области видимости" в разделе Hoisting.</p>
        <img src="./img/declaration1.jpg" alt="">
        <p>С другой стороны, при таком синтаксисе может быть сложно отследить связь между местом объявления функции и местом ее вызова. 
            Современные гайды по стилю кода, составленные большими компаниями с многолетним опытом разработки, 
            так же склоняется к использованию функциональных выражений. Поэтому рекомендуется использовать функциональные выражения, 
            вместо объявлений функции.</p>
        <img src="./img/declaration2.jpg" alt="">


        <h1>Область видимости</h1>
        <p><b>Область видимости (scope)</b> — это независимая от языка концепция, 
            которая описывает доступность переменных в исполняемом коде.</p>
        <p><b>Scope chain (цепочка областей видимости)</b> - области видимости образуют иерархию, так что дочерние области имеют доступ 
            к переменным из родительских областей, но не наоборот.</p>
        <p>Есть три типа областей видимости:</p>
            <ul>
                <li>Переменные, объявленные на самом верхнем уровне, то есть вне любых конструкций вроде if, while, for и функций, 
                    находятся в <b>глобальной</b> области видимости.</li>
                <li>Переменные, объявленные внутри инструкций if, циклов и других блоков кода находятся в <b>блочной</b> области видимости.</li>
                <li>Переменные, объявленные внутри функций, находятся в <b>области видимости функции</b>.</li>
            </ul>
            <p>Это можно представить как дом с комнатами. Дом находится в глобальной области видимости. 
                Каждая функция и блок создают новую комнату, вложенную внутрь дома. Переменные, объявленные внутри этих комнат, 
                доступны только тогда, когда вы находитесь внутри этой комнаты. Вне комнаты эти переменные недоступны.
            </p>
            <img src="./img/diff-scopes.jpg" alt="">
            <p>Интерпретатор пытается сначала найти переменную в той области видимости, в которой к ней обратились. 
                Если такой переменной в локальной области видимости нет, то он выходит наружу, на один уровень за попытку, 
                пока не найдёт значение или не дойдет до самой верхней области видимости (глобальной) и поймет, 
                что переменную с таким идентификатором невозможно найти, так как ее просто нет, тогда будет ошибка о том, 
                что переменная не объявлена.
            </p>
            <p>Функция add возвращает сумму a и b. Переменная a объявлена внутри функции, b нет.</p>
            <img src="./img/add.jpg" alt="">
            <p>Пытаясь решить выражение a + b, интерпретатор ищет значения a и b. Поиск начинается внутри локальной области видимости 
                — внутри функции add. Он находит значение a и переходит к b. 
                Невозможно найти значение b в локальной области видимости, поэтому поиск расширятеся до наружной области. 
                Тут он находит b — это 10. Выражение a + b превращается в 5 + 10, в результате получаем 15.</p>
            
            <h2>2. Область видимости функции</h2>
            <p>Как уже говорилось, функции создают собственную локальную область видимости. Переменные, созданные внутри функции, 
                включая параметры, локальны внутри этой функции и не доступны коду из вне. 
                Локальные переменные будут создаваться каждый раз при вызове функции, и их отдельные инкарнации никак друг с другом не связаны.</p>
            <p>Глобальный value объявлен вне тела функции и его значение будет выведено в консоль. 
                Локальный value внутри функции add по прежнему виден только внутри этой функции. 
                Эти два value не имеют ничего общего друг с другом, они находятся в разных областях видимости. 
                Они не схлопываются в одно целое, не смотря на то, что у них одно и то же имя. 
                В свою очередь innerValue не доступна вне тела функции.
            </p>
            <img src="./img/fn-scope.jpg" alt="">
            <p>Такое поведение помогает предотвратить случайное взаимодействие между функциями. 
                Если бы все переменные использовались в любом месте программы, было бы очень трудно убедиться, 
                что одна переменная не используется для разных операций.</p>
            <p>Относясь к локальным для функций переменным так, что они существуют только внутри функции, 
                язык делает возможным работу с функциями будто с изолированными контейнерами, 
                что позволяет не волноваться про весь код целиком.</p>
            
            <h2>3. Hoisting</h2>
            <p>В языках программирования, в том числе в JavaScript, код исполняется в две фазы.</p>
            <p><b>Фаза компиляции, интерпретации или оценки (compile time, evaluation time)</b> 
                - подготовка перед исполнением кода, проверка валидности синтаксиса исходного кода.</p>
            <p>Во время этой фазы компилятор или интерпретатор находит синтаксические ошибки, ошибки типизации и т. д. 
                То есть код еще не выполняется, только оценивается. Если эта фаза прошла успешно, 
                это как минимум значит что в коде нет синтаксических ошибок и его можно запустить на исполнение.</p>
            <p><b>Фаза исполнения (runtime)</b> - скрипт начинает исполняться, выполняются инструкции вызовов функций и оценки выражений, 
                роисходит поиск необходимых идентификаторов в соответствующих областях видимости и тому подобное.</p>
            <p>Если эта фаза завершилась успешно, значит скрипт написан без явных ошибок и закончил свою работу. 
                На этой фазе могут быть ошибки связанные с отсутствующими свойствами и переменными, преобразованием типов и т. д., 
                то есть что-то, что происходит только во время выполнения кода.</p>
            <p>Попробуйте выполнить следующий код. 
                Так как мы сделали опечатку и вместо const пытаемся объявить переменную value ключевым словом cos, 
                на фазе компиляции будет выявлена синтаксическая ошибка и фаза исполнения даже не запустится. 
                В консоли мы сразу увидим сообщение об ошибке.</p>
            <img src="./img/hoisting.jpg" alt="">
            <p>Поднятие переменных (hoisting) - это механизм интерпретатора, который, до фазы исполнения кода, 
                поднимает объявления переменных в начало области видимости (блочной или функции) в которой они были объявлены.</p>
            <p>Именно поэтому работает function declaration и так странно ведут себя переменные объявленные используя var - 
                их объявления поднимаются в начало области видимости функции в которой они были объявлены.</p>
            <img src="./img/hoisting1.jpg" alt="">
            <p>Переменные объявленные используя let или const так же поднимаются, но при этом подчиняются блочной области видимости, 
                ничем не инициализируются по умолчанию и не доступны для обращения до того места в коде где были объявлены в коде.</p>
            <img src="./img/hoisting2.jpg" alt="">
            <p>Более детально про поднятие идентификаторов и ключевые словах var, let и const 
                читайте <a href="https://codeburst.io/const-let-and-var-which-and-when-541a2721c18?gi=36373a825ae9">в этой статье</a>.</p>
            

            <h2>1. Стрелочные функции</h2>
            <p>Стрелочные функции имеют сокращенный, более лаконичный синтаксис, и некоторые особенности. 
                Подобно функциональным выражениям они присваиваются переменным или могут быть анонимными. 
                Их использование очень удобно и значительно сокращает объемы кода, особенно когда функция маленькая.</p>
            <p>Все стрелки создаются с помощью функционального выражения, если функция не анонимна, 
                то она должна быть присвоена переменной. 
                Поэтому следует помнить, что перед использованием стрелочной функции её всегда необходимо создать заранее.</p>
            <img src="./img/arrow.jpg" alt="">
            <p>Слово function не используется, вместо этого сразу идет объявление параметров, за которыми всегда следует символ =>.</p>
            <img src="./img/arrow2.jpg" alt="">
            <p>После => идет тело функции. Здесь может быть два варианта: с фигурными скобками и без них.</p>
            <img src="./img/arrow3.jpg" alt="">

            <h2>2. Стрелочные функции и arguments</h2>
            <p>У стрелочных функций нет локальной переменной arguments, содержащей все аргументы. 
                Если необходимо собрать все аргументы в массив, используется операция rest.</p>
            <img src="./img/arrow4.jpg" alt="">
            








            
    </body>
</html>

        
        









</body>
</html>